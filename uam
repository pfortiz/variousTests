#! /usr/bin/env python

# Script to deal with the definition of assets (sites and sensors) in the
# Urban Flows Observatory, Sheffield.
#
# This code should help to build the database (command line oriented)
# It should also be capable to retrieve the state of all the assets at a
# certain time. This is the information which shall be fed to the
# web-interface for any particular point in the time-line.


# variables:
# siteId (char array)
# sensorId (integer)
# timeStamp (integer)
# Carbon Monoxide
# Nitric Oxide
# Nitrogen Dioxide
# Relative Humidity
# Temperature
# Battery
# Noise

# string timestamp not incorporated into binary file.
#
#UoS_AJ_702 100702 2016/10/30T00:05:08 1477782308 0.61 1.43 30.04 81.70 12.60 3.55 57.00
# as well as trying to get the content of an url into a file using urllib
from numpy import array
import numpy as np
import os
import sys
import time
import json
#import urllib
import csv

#
# This script is meant to be in the examples repository. 
#
# The next statement needs to be changed if it is copied somewhere else and
# the correct path to plotopy has to be provided.

plotopyPath = os.environ['PLOTOPY']
sys.path.append(plotopyPath)


import timeXtras  as tx

#print plotopyPath
import time
import datetime
import getpass

ctime =  time.time()
maintenant = ctime
#print ctime
alora = str(datetime.datetime.now())
dt = alora.split()
laDate = int(dt[0].replace("-", ""))
idf = "%d-%m-%Y";
idtf = '%Y-%m-%dT%H:%M:%S'
heute = time.strftime("%d-%m-%Y")
#print alora, laDate, heute
hms = dt[1].split(":")
leTime = int(hms[0])/24.0 + float(hms[1])/1440. + float(hms[2])/86400;
#print "date", dt[0], laDate, " time ", dt[1], " fod", leTime
stamp = "{:.6f}".format(laDate + leTime)
#print "Stampo : ", stamp
epoch = datetime.datetime(1970, 1, 1)
#print "epoch = " , epoch
assetsFile = "/Users/Shared/ufloTables/assets.db"
lcDict = {}
HISTORY = "h"
LOGGER = "log"
XDATE = "xdate"
SITES = "sites"
SENSORS = "sensors"
SENSORID = "za"
DETECTORS = "dk"
LISTOFDETECTORS = "ld"
LISTOFSENSORS = "lz"
LISTOFSITES = "ls"
SITELON = "slo"
SITELAT = "sla"
TSTAMP = "hT"
LOGTIME = "hL"
HACTION = "hA"
CLSTATUS = "status"
HSTATUS = "hS"
PAIRS = "pairs"

def histoire(hstamp, action, key, value):
    hist = {}
#    hist["hrStamp"] = hstamp
    # hist[TSTAMP] = stime2utime(hstamp)
    if not hstamp is None:
        hist[TSTAMP] = time.mktime(datetime.datetime.strptime(hstamp, idf).timetuple())
    hist[LOGTIME] = time.time()
#    hist["hrLogTime"] = str(datetime.datetime.now())
    hist[HACTION] = action
    hist[key] = value
    hist["hu"] = uname
    return hist

#handles = {
#        "siteid" : "site ID",
#        "address" : "Street Address",
#        "lon" : "longitude [deg]",
#        "lat" : "latitude [deg]",
#        "hag" : "Height above ground [m]",
#        "hasl" : "height above sea level [m]",
#        "zip" : "Postal Code",
#        "city" : "City",
#        "country" : "Country",
#        "firstdate" : "Start Date DD-MM-YYYY",
#        "operator" : "Operated by",
#        "sensorid" : "Sensor ID",
#
#        "provider" : "Sensor provider name",
#        "nquantities" : "Number of quantities measured",
#        "qname" : "Quantity measured",
#        "qunits" : "Quantity units",
#        "quncertainty" : "Quantity uncertainty",
#        "qucd" : "Quantity associated UCD",
#        "serialnumber" : "Sensor serial number",
#
#        "ifilename" : "Input file name",
#}



#actions = ["addSite", "addSitesFromFile",
#            "addSensor", "addSensorsFromFile",
#            "attachSensorToSite", "detachSensorFromSite",
#            "showSensorSite",
#            "addMaintenance", "terminate"];


actionsHelp = {
    "getInputTemplate": {
        "args":"type=<site|sensor> [n=N] [ > <input_file>]",
        "Args":{"m":["type"], "op":["n"], "mc":[] },
        "short": "Prints a template to stdout to enter sensor or site data from files. If 'n=X' is specified, X templates are produced.",
        "long":"""Generate one or more templates to enter sensor or site basic data.

You are advised to redirect the output to a filename for you to
edit and enter all information relative to that sensor/site.

Note that if you have other pieces of information not shown in the list,
just add them as key=value in extra lines."""
        },
    "addSitesFromFile": {
        "args":"file=input_file",
        "short":"Add a list of sites from a file",
        "long": """Enter a list of sites from a file.
  Template files can be obtained with:
    uam getInputTemplate site """
        },
    "closeSite": {
        "args":"site=siteid",
        "short":"Mark the site as closed",
        "long": """Mark a given site with status closed."""
        },
    "addSensorsFromFile": {
        "args":"file=filename", 
        "short":"Add a list of sensors from a file",
        "long":"""Add a list of sensors from data stored in a file. 
  Template files can be obtained with:
    uam getInputTemplate sensor"""
        },
    "attachSensorToSite": {
        "args":"sensor=sensorID site=siteID hag=height_above_ground_[m] date=DD-MM-YY ",
        "short":"Pair a sensor to a site at a given date",
        "long":"""Indicate when a sensor is physically attached into a site.
Data starts being collected but it is unreliable.
The height-above-ground is mandatory, and indicate the location of the
"sensor-box" with respect to the ground.
Use activateSensorInSite to mark the moment data from all sensors is reliable."""
        },
    "activateSensorInSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Indicate when reliable data gathering begins",
        "long":"""Mark when a sensor starts collecting reliable data"""
        },
    "deactivateSensorInSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Indicate when unreliable data gathering begins",
        "long":"""Mark when a sensor starts collecting data considered unreliable """
        },
    "detachSensorFromSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Detach a sensor from a site at a specific date+time.",
        "long":"""Detach a sensor from a site at a specific date+time"""
        },
#    "addDetectorInformation": {
#        "args":"sensor=sensorID detector=measured-quantity <info> <date>",
#        "short":"Alter the status of data collection for an individual detector attached to a sensor.",
#        "long":"""As detectors can go rogue, this is a way to indicate when
#a detector has gone belly up or is back to normal.
#info=on   indicates a perfectly working detector
#info=anything-else indicates the detector is acting up and it will be used
#to avoid providing data for that detector while its status is not back to 'on'"""
#        },
    "deactivateSite": {
        "args":"<siteID> ",
        "short":"mark a site as decommissioned",
        "long":"""Mark a site as decommissioned """
        },
    "rminfo": {
        "args":"tag=history-tag",
        "short":"removes the entry pointed by 'history-tag' from the corresponding history entry",
        "long":"""Removes a history entry with the label 'history-tag'. 
'history-tag' shall be obtaining from the last column found when a history
is shown by the use of the 'show' option."""
        },
    "addinfo": {
        "args":"info=flag|field|maintenance [siteid=xxx] [sensorid=yyy] [detector=zzz] value=vvv msg='mmm' date=DD-MM-YYYY",
        "short":"adds information to assets at various levels",
        "long":"""addinfo allows to incorporate information to the dictionry at
several levels. The operations allowed are:
uam addinfo info=flag to either a site, a sensor or sensor's detector.
           This operation affects the status of a device.
           status=on indicates the asset is active, operational and collecting
                meaningful data. 
           status='whatever-else' will make data starting at that ponit not to
                be considered 'suitable for analysis'
uam addinfo info=field: allow for the inclusion of fields omitted at the moment of
           writing this software to any element. Date is ignored. If value
           is a comma separated list of words, a list is entered in the
           field.
uam addinfo info=log. Like flag, except that the status of an asset is not
           altered, but an item in the maintenance field of the asset is
           added. value TBD as of Nov-30,2017

?uam addinfo info=maintenance. Like flag, except that the status of an asset is not
           altered, but an item in the maintenance field of the asset is
           added. value TBD as of Nov-30,2017
"""
        },
    "show": {
        "args": "element [date=x]",
        "short":"Show a particular database element now or at the specified date",
        "long":"""show allows you to examine different aspects of the data.
Valid entries are:
uam show sensor=<sensorid>|*   Show data for one sensor or all if * is used
uam show site=<siteid>|*       Show data for a site or all if * is used
uam show pair=<sensor,site>|*  Show data for a pair sensor + site
uam show log                   Show the activity as it was entered
uam show chronology            Show the sequence of operations on sensors,
                               sites, etc
uam show dictionary            Show the whole data structure
uam show operational [date=x]      Show all active sites at date DD-MM-YYYY

?uam show activeSites date      Show all active sites at date DD-MM-YYYY
?uam show activeSensors date    Show all active sensors at date DD-MM-YYYY
?uam show activePairs date      Show all active sensor/site pairs at DD-MM-YYYY
        """
        },
    "help": {
        "args":"[<action>]",
        "short": "Show help for an action or in general.",
        "long":"""Show some help for a given action"""
        },
    "identify": {
        "args": "<asset> status=sss [from=DD-MM-YYYY] [to=DD-MM-YYYY] [verbose]",
        "short":"Show periods when status = sss for a given asset",
        "long":"""identify allows you to determine periods of time when the
status has a given value for various assets.
Valid usages are:
uam identify sensor=<sensorid>          Show equal status periods for a sensor
uam identify site=<siteid>              Show equal status periods for a site
uam identify pair=<sensorid,siteid>     Show equal status periods for a pair
uam identify detector=<sensorid,detid>  Show equal status periods for a detector

sensorid, siteid, detid can be replaced by * to show all occurances.
from= determines the earliest date to perform the search. Default: 01-01-2015
to= determines the latest date to perform the search. Default: today
If verbose is specified, all history entries are shown in addition"""
        },

    };

helpOrder = [
    "addSitesFromFile",
    "addSensorsFromFile",
    "getInputTemplate",
    "attachSensorToSite",
    "detachSensorFromSite",
    "activateSensorInSite",
    "deactivateSensorInSite",
    "deactivateSite",
    "identify",
    "addinfo",
    "rminfo",
    "show",
    "help",
#    "showOperational",
#    "showDictionary",
#    "showSensorSite",
#    "addSite",
#    "addSensor",

    ];


# these are the fields the user is given in the template file.
# It would be better to have a translation table between what is presented
# to the human eye and what goes 
templateArgs = {
    "site" : [
        "siteid", "address", "city", "country", "zip", "lon", "lat",
        "hasl", "firstdate", "operator", "sensorid"
        ],
    "sensor" : [
        "sensorid", "provider",  "firstdate", "energysupply",
        "freqmaintenance", "family", "data-acquisition-period_[min]",
        "serialnumber", "ndetectors", 
        ],
}

templateObjs = {
    "site" : [
        {"sa":"siteid"},
        {"sb":"address"},
        {"sc":"city"},
        {"sd":"country"},
        {"se":"Postal_Code"},
#       { "sf":"height_above_ground_[m]"},
        {"sg":"height_above_sea_level_[m]"},
        {"sh":"firstdate"},
        {"si":"epoch.f"},
        {"sj":"date.l"},
        {"sk":"epoch.l"},
        {SITELON:"longitude_[deg]"},
        {SITELAT:"latitude_[deg]"},
        {"sn":"operator"},
        {"h":"history"},
        {"u":"username"},
        ],
    "detector" : [
        {"dn":"name"},
        {"du":"unit"},
        {"de":"epsilon"},
        {"dz":"ucd"},
    ],
    "sensor" : [
        {"za":"sensorid"},
        {"zb":"provider"}, 
        {"zc":"serialnumber"},
        {"zd":"energysupply"},
        {"ze":"freqmaintenance"},
        {"zf":"family"},
        {"zg":"data-acquisition-interval[min]"},
        {"zh":"detector"},
        {"zi":"firstdate"},
        {"zj":"epoch.f"},
        {"zk":"date.l"},
        {"zl":"epoch.l"},
        {"zz":"n-detectors"},
        {"h":"history"},
        {"ld":"listOfDetectors"},
        ],
}

revTemplate = {}
dirTemplate = {}

ucds = {
    "MET_TEMP" : ["Temp", "T", "Temperature"],
    "MET_RH" : ["RH", "RelHum", "RelativeHumidity"],
    "MET_AP" : ["Pressure", "AirPressure", "barometricpressure"],
    "AQ_NOISE" : ["Noise"],
    "AQ_CO" : ["CO"],
    "AQ_NO" : ["NO"],
    "AQ_NO2" : ["NO2"],
    "AQ_SO2" : ["SO2"],
}

#arguments = {
#    "addsite" : [
#        "siteid", "address", "city", "country", "zip", "lon", "lat",
#        "hag", "hasl", "firstdate", "operator", "sensorid"
#        ],
#    "addsitesfromfile" : [
#        "ifilename"
#        ],
#    "addsensorsfromfile" : [
#        "ifilename"
#        ],
#    "addsensor" : [
#        "sensorid", "provider",  "firstdate",
#        "serialnumber", "siteid", "nquantities", 
#        ],
#    "quantity" : [
#        "qname", "qunits", "quncertainty", "qucd"
#        ],
#    "show" : [
#        "qname", 
#        ],
#    "getinputtemplate" : [
#        "qname", "qunits", "quncertainty", "qucd"
#        ],
#    "attachsensortosite" : [ "qucd" ],
#    "activatesensorinsite" : [ "qucd" ],
#    "deactivatesensorinsite" : [ "qucd" ],
#    "detachsensorfromsite" : [ "qucd" ],
#    "adddetectorinformation": [ "qucd" ],
#    "addinfo": [ "qucd" ],
#    "rminfo": [ "qucd" ],
#    "identify": [ "qucd" ],
##    "showsensorsite" : [ "qucd" ],
#    "help" : [ "aiuta" ],
#}

def stime2utime(stime):
    return time.mktime(datetime.datetime.strptime(stime, idf).timetuple())

def histKiller(obj, tag):
    qtag = "{:.6f}".format(float(tag))
#    print "HK"
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
                if k == HISTORY:
#                    print "IT:", k, v
                    i = 0
                    for h in v:
                        rtag = "{:.6f}".format(h[LOGTIME])
                        if rtag == qtag:
#                            print "hk-Eureka", rtag, qtag
                            del v[i]
                        i += 1

                else:
                    histKiller(v, tag)
#            else:
#                if k == LOGTIME:
#                    if qtag == tag:
#                        print obj
#                        print '%s :-: %s vs %s' % (k, qtag, tag)
    elif type(obj) == list:
#        print "OL", obj
        for v in obj:
            if obj == HISTORY:
                print "IH:", obj
            if hasattr(v, '__iter__'):
                histKiller(v, tag)
            else:
                if v == TSTAMP:
                    print "V: ", v
    else:
        if obj == TSTAMP:
            print "O", obj


def do_rmInfo(gDict, args):
    """
    Function to remove an entry from any of the history lists
    """
#    if len(args) == 0:
#        do_showHelp(gDict, ["rminfo"])
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["tag"], [])
    if fail["truth"]:
        sys.exit()

    theInfo = fail["tag"]

    if theInfo == "history":
        prefix = "Usage: uam rminfo history"
        fail = checkPresence(doThis, ["histoid"], ["histoid"])
        if fail["truth"]:
            print prefix, "histoid=xxx.xxx"
            sys.exit()
        theTag = doThis["histoid"]
#        print "Trying to remove: ", theTag
        print "GDOr:", len( json.dumps(gDict) )
#        print gDict[LOGGER]
        odict = gDict.copy()
        histKiller(gDict, theTag)
        print "GDMod:", len( json.dumps(gDict) )
#        print gDict[LOGGER]
        event = histoire(None, "entry {} rm(history).".format(theTag),
                XDATE, heute)

    elif theInfo == "field":
        fail = checkPresence(doThis, ["fname"],
                    ["sensorid", "siteid"])

        if fail["truth"]:
            print "Usage: uam rminfo field sensorid=xxx fname='mmm'"
            print "Usage: uam rminfo field siteid=xxx fname='mmm'"
            sys.exit()
        field = doThis["fname"]
        if "sensorid" in doThis:
            sensorId = doThis["sensorid"]
            if sensorId not in gDict[SENSORS]:
                print sensorId, "is not an existing sensor. Quiting"
                sys.exit()
            sensor = gDict[SENSORS][sensorId]

            if field in sensor:
                del sensor[field]
            else:
                print field, "not part of ", sensorId
                sys.exit()
            event = histoire(None, 
                "{} removed from sensor {}.".format(field, sensorId),
                XDATE, heute)
        elif "siteid" in doThis:
            siteId = doThis["siteid"]
            if siteId not in gDict[SITES]:
                print siteId, "is not an existing site. Quiting"
                sys.exit()
            site = gDict[SITES][siteId]
            if field in site:
                del site[field]
            else:
                print field, "not part of ", siteId
                sys.exit()
            event = histoire(None, 
                "{} removed from sensor {}.".format(field, sensorId),
                XDATE, heute)
    else:
        print theInfo, "is not a valid 'thing' to remove from an asset"
        sys.exit()
    pass
    gDict[LOGGER].append(event)
    print "GDfinal:", len( json.dumps(gDict) )
#    print gDict[LOGGER]
    sys.exit()

    pass

def do_addInfo(gDict, args):
    """
    Function to add information to an asset
    """
#    if len(args) == 0:
#        do_showHelp(gDict, ["addinfo"])
#    
#    (doThis, todo) = splitArgs(args)
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["info"], [])
    if fail["truth"]:
        sys.exit()

    theInfo = doThis["info"]
    dateForm = "date=DD-MM-YYY[Thh:mm:ss.s]"

    if theInfo == "flag":
        usg = "uam addinfo flag"
        prefix = "Usage: {}\n".format(usg)
        fail = checkPresence(doThis, ["msg", CLSTATUS, "date"],
                    ["sensorid", "siteid", "pairid", "detid"])
#        if ("sensorid" not in doThis) and ("siteid" not in doThis) and ("pairid" not in doThis) and ("detectorid" not in doThis):
        if fail["truth"]:
            print "{}: Change the status of a sensor/site/detector".format(usg)
            print "{} sensorid=xxx msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} siteid=xxx msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} pairid=sensorid:siteid msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} detid=sensorid:det msg='mmm' status=vvv {}".format(prefix,dateForm)
            sys.exit()
        if "sensorid" in doThis:
            asset = fail["sensorid"]
#            hRoot = gDict[SENSORS]
#            history = hRoot[asset["uid"] ][HISTORY]
        elif "siteid" in doThis:
            asset = fail["siteid"]
#            hRoot = gDict[SITES]
#            history = hRoot[asset["uid"] ][HISTORY]
#            history = gDict[SITES][asset["uid"] ][HISTORY]
#            siteId = doThis["siteid"]
#            site = fail["siteid"]
#            if site is None:
#                sys.exit()
#            uid = site["uid"]
#            msg = "{} {}".format(uid, doThis["msg"])
        elif "pairid" in doThis:
            asset = fail["pairid"]
#            hRoot = gDict[PAIRS]
#            history = hRoot[asset["uid"] ][HISTORY]
#            history = gDict[PAIRS][asset["uid"] ][HISTORY]
#            thePair = fail["pairid"]
#            if thePair is None:
#                sys.exit()
#            uid = thePair["uid"]
#            history = gDict[PAIRS][asset["uid"] ][HISTORY]
#            msg = "{} {}".format(uid, doThis["msg"])
#            pass
        elif "detid" in doThis:
            asset = fail["detid"]
#            detPair = doThis["detid"]
#            if tdet is None:
##                print "{} is not a valid detector.".format(detPair)
#                sys.exit()
#            print "Detector", tdet["uid"], " at:", tdet
#            history = tdet[HISTORY]
#            msg = "{} {}".format(tdet["uid"], doThis["msg"])
#            pass

        if asset is None:
            sys.exit()
        assetId = asset["uid"]
        history = asset[HISTORY]
        msg = "{} {}".format(assetId, doThis["msg"])

#        print "New message: ", msg
#        print "New status:  ", doThis[CLSTATUS]
        event = histoire(doThis["date"], doThis["msg"], HSTATUS,
                        doThis[CLSTATUS])
        insert(event, history)
        then = heute


    elif theInfo == "field":
        fail = checkPresence(doThis, ["fname", "fvalue"],
                    ["sensorid", "siteid", "pairid", "detid"])

        if fail["truth"]:
            print "Usage: uam addinfo field sensorid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field siteid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field pairid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field detid=xxx fname='mmm' fvalue=vvv"
            sys.exit()
        if "sensorid" in doThis:
            asset = fail["sensorid"]
        elif "siteid" in doThis:
            asset = fail["siteid"]
        elif "pairid" in doThis:
            asset = fail["pairtid"]
        elif "detid" in doThis:
            asset = fail["detid"]
#            if asset is None:
#                sys.exit()
#            assetId = asset["uid"]
#            asset[doThis["fname"]] = doThis["fvalue"]
#            msg = "{} = {} added to {}".format(doThis["fname"], 
#                        doThis["fvalue"].replace(" ", "_"), assetId)
#            print "Site after: ", site
        if asset is None:
            sys.exit()
        assetId = asset["uid"]
        asset[doThis["fname"]] = doThis["fvalue"]
        msg = "{} = {} added to {}".format(doThis["fname"], 
                        doThis["fvalue"].replace(" ", "_"), assetId)
        then = heute
    elif theInfo == "maintenance":
        fail = checkPresence(doThis, ["sensorid", "msg", "value", "date"], [])
        if fail["truth"]:
            print "Usage: uam addinfo maintenance sensorid=xxx msg='mmm' value=vvv date=DD-MM-YYYY"
            sys.exit()
        
        sys.exit()
        sensorId = doThis["sensorid"]
        if sensorId not in gDict[SENSORS]:
            print sensorId, "is not an existing sensor. Quiting"
            sys.exit()
        sensor = gDict[SENSORS][sensorId]
        sensor[doThis["fname"]] = doThis["fvalue"]
        msg = "{} = {} added to {}".format(doThis["fname"], 
                        doThis["fvalue"], sensorId)
        then = heute
        msg = doThis["msg"]
        event = histoire(doThis["date"], doThis["msg"], XDATE,
                        doThis["date"])
        insert(event, history)
        pass
    elif theInfo == "log":
        fail = checkPresence(doThis, ["msg", "date"], [])
        if fail["truth"]:
            print "Usage: uam addinfo log msg='mmm' date=DD-MM-YYYY"
            sys.exit()
        then = heute
        msg = doThis["msg"]
        event = histoire(doThis["date"], doThis["msg"], XDATE,
                        doThis["date"])
        insert(event, gDict[LOGGER])

        pass
    else:
        print theInfo, "is not a valid 'thing' to add to an asset"
        sys.exit()
    pass
    event = histoire(then, msg, XDATE, then)
    gDict[LOGGER].append(event)

def checkPresence(doit, mustHave, oneAtLeast):
    fmh = False
    answer = {}
    answer["truth"] = False
    answer["sensorid"] = None
    answer["siteid"] = None
    answer["pairid"] = None
    answer["detid"] = None
    answer["type"] = None
    for mh in mustHave:
        if mh not in doit:
            print "{}=x not defined".format(mh)
            fmh = True
        else:
            answer[mh] = doit[mh]
    if fmh:
        answer["truth"] =  True

    if set(oneAtLeast) != set(mustHave) and len(oneAtLeast) > 0:
        foal = False

        for mh in oneAtLeast:
            if mh in doit:
                foal = True
                ass_et = doit[mh]
                if mh == "sensorid":
                    answer[mh] = getSensor(ass_et)
                elif mh == "siteid":
                    answer[mh] = getSite(ass_et)
                elif mh == "pairid":
                    answer[mh] = getPair(ass_et)
                elif mh == "detid":
                    answer[mh] = getDetector(ass_et)
                elif mh == "type":
                    if ass_et == "site" or ass_et == "sensor":
                        answer[mh] = ass_et
                    pass
        if foal == False:
            print "one of {} must be defined".format(oneAtLeast)
            answer["truth"] =  True
    if answer["truth"]:
        sys.exit()
    return answer

def getSensor(sid):
    if sid.lower() not in lcDict[SENSORS]:
        print sid, "is not an existing sensor. Quiting"
        return None
    else:
        tsid = lcDict[SENSORS][sid.lower()]
        gDict[SENSORS][tsid]["uid"] = tsid
        return gDict[SENSORS][tsid]

def getSite(sid):
    if sid.lower() not in lcDict[SITES]:
        print sid, "is not an existing site. Quiting"
        return None
    else:
        tsid = lcDict[SITES][sid.lower()]
        gDict[SITES][tsid]["uid"] = tsid
        return gDict[SITES][tsid]

def getPair(sid):
    (sensId, sitId) = sid.split(',')
    lePair = "{}|{}".format(sitId, sensId)
    riaPel = "{}|{}".format(sensId, sitId)
    pairs = lcDict[PAIRS]
    print pairs
    if lePair.lower() in pairs.keys():
       rLePair = pairs[lePair.lower()]
       thePair = gDict[PAIRS][rLePair]
       thePair["uid"] = rLePair
    elif riaPel.lower() in pairs.keys():
       rRiaPel = pairs[riaPel.lower()]
       thePair = gDict[PAIRS][rRiaPel]
       thePair["uid"] = rRiaPel
    else:
       print "invalid pair ({} or {}), sorry, can't continue.".format(lePair, riaPel)
       thePair = None
    return thePair
#    if thePair not in gDict[SITES]:
#        print sid, "is not an existing site. Quiting"
#        return None
#    else:
#        return gDict[SITES][sid]
#            pairId = doThis["pairid"]
#                sys.exit()
#            print pairId, thePair

def getDetector(sid):
#            detPair = doThis["detid"]
    (sensId, detId) = sid.split(',')
    sensor = getSensor(sensId)
    if sensor is None:
        return None
    did = "{}.{}".format(sensor["uid"],detId)
    lod = sensor[LISTOFDETECTORS]
    if did.lower() not in lcDict["detectors"].keys():
        print "{} is not a detected quantity in {}".format(detId, sensId)
#        sys.exit()
        return None
    detId = lcDict["detectors"][did.lower()]
    print "Located dectector: ", detId
    sensor[DETECTORS][detId]["uid"] = "{}.{}".format(sensor["uid"],detId)
    print "Detector: ", sensor[DETECTORS][detId]

    return sensor[DETECTORS][detId]
#    if sid not in gDict[SITES]:
#        print sid, "is not an existing site. Quiting"
#        return None
#    else:
#        return gDict[SITES][sid]

def do_showHelp(gDict, args):
    """
    Function to show help about a given command
    """
    if len(args) == 0:
        h = """uam: The urbanFlows Asset Manager

This is a command line tool which takes several arguments to achieve
different functionality.
You can see all arguments by invoking 'uam' without arguments

Help is provided for each of the possible arguments by typing:

uam showHelp <action>
<action> can be any of:
"""
        print h, theActions
        return
    subject = args[0].lower()
#    print "Help-subject: ", subject
    laKey = None
#    for key in actionsHelp.keys():
    for key in helpOrder:
#        print "SB: {}|".format( subject)
#        print "KL: {}|".format( key.lower())
        if subject == key.lower():
            laKey = key
            break
    if laKey is None:
        print "Invalid help action"
        sys.exit()

    aha = actionsHelp[laKey]
#    print "uam", subject, aha
    print "Usage:\n    uam", subject, aha["args"]
    print "\n{}".format( aha["long"] )
    sys.exit()

def liveAt(history, limit):
    if limit is None:
        return True
    stt = False
    for h in history:
        if h[TSTAMP] > limit:
            return stt
#        print h[TSTAMP], limit, h[HSTATUS]
        if h[HSTATUS] == "on":
            stt = True
        else:
            stt = False
    return stt

def showSite(site, gDict, limitUstamp, hDate, activity):
    if not liveAt(gDict[SITES][site][HISTORY], limitUstamp):
        print site, "not active"
        return

    (dkey, revKey) = revert(["site"])
    print "DK:", dkey
    print "RK:", revKey

#    print "date comparison: ", firstUs, limitUstamp
    if activity:
        print "activity for site: ", site
        k = HISTORY
        print " {}.{}".format(site, k)
        hist = gDict[SITES][site][k]
        showHist({HACTION:"Action", HSTATUS:"Status"}, None)
        for he in hist:
            showHist(he, limitUstamp)
    else:
        print "Data for site: ", site
        for k in sorted(gDict[SITES][site].keys()):
            if k in dkey:
                dk = dkey[k]
            else:
                dk = k

            if k == HISTORY:
                print " {}.{}".format(site, dk)
                hist = gDict[SITES][site][k]
                showHist({HACTION:"Action", HSTATUS:"Status"}, None)
                for he in hist:
                    showHist(he, limitUstamp)
            else:
                print " {}.{}= {}".format(site, dk, gDict[SITES][site][k])

def showSensor(sensor, gDict, showH, limitUstamp, hDate, activity):
    leSensor = gDict[SENSORS][sensor]

    if not liveAt(leSensor[HISTORY], limitUstamp):
        print sensor, "not active"
        return

    (dkey, revKey) = revert(["sensor", "detector"])
#    sensTags =  templateObjs["sensor"]
#    for p in sensTags:
#        for kk in p.keys():
#            revKey[kk] = p[kk]
#    sensTags =  templateObjs["detector"]
#    for p in sensTags:
#        revKey[sensTags[p]] = p

    # date detection should occur here
    if activity:
        k = HISTORY
        hist = leSensor[k]
        print " {}.{}:".format(sensor, k)
        showHist({HACTION:"Action", HSTATUS:"Status"}, None)
        for he in hist:
            showHist(he, limitUstamp)
        pass
    else:
        print "Data for sensor: ", sensor 
        for k in sorted(leSensor.keys()): # gDict[SITES][site].keys()):
            if k in dkey:
                dk = dkey[k]
            else:
                dk = k
            if DETECTORS in k:
                continue
            if k == revKey["provider"]:
    #            print leSensor[k]
                p = sorted(leSensor[k].keys())
                for e in p:
                    f = leSensor[k][e]
                    print " {}.{}.{} = {}".format(sensor, dk, e, f)
                pass
            elif k == LISTOFDETECTORS:
                dets = []
                for d in leSensor[k]:
                    dets.append(str(d))
                print " {}.{}= {}".format(sensor, dk, dets)
            elif k == HISTORY and showH == True:
                hist = leSensor[k]
                print " {}.{}:".format(sensor, dk)
                showHist({HACTION:"Action", HSTATUS:"Status"}, None)
                for he in hist:
                    showHist(he, limitUstamp)
            elif k == HISTORY and showH == False:
                print " {}.{}:".format(sensor, dk)
            else:
                print " {}.{}= {}".format(sensor, dk, leSensor[k])
    
        if showH == False:
            return
        shist = leSensor[HISTORY]
        print sensor,  "detectors:"
        for ms in leSensor[LISTOFDETECTORS]:
            qtty = leSensor[DETECTORS][ms]
            label = "{}.{}".format(sensor, ms)
            print " {:25s}".format(label), ms, qtty['du'], qtty['dz']
    
            if len(qtty[HISTORY]) > 0:
#                chist = shist
                chist = []
                for h in shist:
                    chist.append(h)
                for h in  qtty[HISTORY]:
                    insert(h, chist)
                print sensor, ms, HISTORY
                showHist({HACTION:"Action", HSTATUS:"Status"}, None)
                for ch in chist:
                    showHist(ch, limitUstamp)

def showHist(entry, limit):
    """
    method to show history items
    """
    if TSTAMP in entry:
        etime = entry[TSTAMP]
        tag = entry[LOGTIME]
        if limit is None:
            mrk = " "
        elif etime < limit:
            mrk = "-"
        else:
            mrk = "+"
        if etime == 32503680000:
            return
        hrTime = datetime.datetime.fromtimestamp( etime).strftime('%Y-%m-%d')
    else:
        hrTime = "Date      "
        mrk = " "
    if CLSTATUS in entry:
        status = entry[CLSTATUS]
    else:
        status = ""

    if LOGTIME in entry:
        lgt = "{:.6f}".format(float(entry[LOGTIME]))
    else:
        lgt = ""

    if HACTION in entry:
        action = entry[HACTION]
    else:
        action = ""
    msg = "{}  {:12s} {:25s} {:10s} {}".format(mrk, hrTime, action, status, lgt)
#    print "  ", hrTime, action, status
    print msg

def splitArgs(args, nmandatory):
    if len(args) < nmandatory:
        do_showHelp(gDict, [laAction])
    doThis = {}
    todo = []
    for arg in args:
        lcarg = arg.lower()
        if "=" in lcarg:
            lcparts = lcarg.split("=")
            parts = arg.split("=")
            doThis[lcparts[0]] = parts[1]
            todo.append(lcparts[0])
        else:
            doThis[lcarg] = None
            todo.append(lcarg)

    return (doThis, todo)

def do_showThings(gDict, args):
    """
    Function to show any dictionary content
    """
#    if len(args) == 0:
#        do_showHelp(gDict, ["show"])
#    
#    (doThis, todo) = splitArgs(args)
    (doThis, todo) = splitArgs(args, 1)
#    fail = checkPresence(doThis, ["item"], [])
#    if fail["truth"]:
#        sys.exit()

    showTime = todo[0]
    iDate = None
    hDate = None
    activity = False
    y3k   = stime2utime("10-01-3000")
#    print "maintenant: ", maintenant
    if "date" in todo:
        hDate = doThis["date"]
        iDate = stime2utime(doThis["date"])
    if "activity" in todo:
        activity = True

    if showTime == "dictionary":
        dicFile = doThis[showTime]
        if not dicFile is None:
#            print "must read a new file and get dictionary"
            assetsFile = "/Users/Shared/ufloTables/{}".format(dicFile)
            if os.path.isfile(assetsFile):
                dfile = open(assetsFile,"r")
                jsonString = dfile.readline().rstrip('\n')
                gDict = json.loads(jsonString)
                dfile.close()
            else:
                print "et maintenant",maintenant
                print assetsFile, " does not exist."
                sys.exit()

        if LISTOFSITES in gDict:
            sites = gDict[LISTOFSITES]
            print "\nList of sites: ", sites
            for site in sites:
                showSite(site, gDict, iDate, hDate, activity)
            
        if LISTOFSENSORS in gDict:
            sensors = gDict[LISTOFSENSORS]
            print "\nList of sensors: ", sensors
            for sensor in sensors:
                showSensor(sensor, gDict, False, iDate, hDate, activity)
    
        if PAIRS in gDict:
            pairs = gDict[PAIRS]
            print "\nList of pairs: ", pairs.keys()
            for pair in sorted(pairs.keys()):
                showPair(pair, gDict, iDate, hDate)
#            for pair in pairs.keys():
#                print pair #, pairs[pair]
#                showHist({HACTION:"Action", HSTATUS:"Status"}, None)
#                for entry in pairs[pair]:
#                    showHist(entry, iDate)

    elif showTime == "sensor":
        if LISTOFSENSORS in gDict:
            sensors = gDict[LISTOFSENSORS]
            print "sensors list: ", sensors
            mysensor = doThis[showTime].lower()
            if mysensor == "*":
                for sensor in sensors:
                    showSensor(sensor, gDict, False, iDate, hDate, activity)
            else:
                for sensor in sensors:
                    if sensor.lower() == mysensor:
#                    if sensor == mysensor:
                        showSensor(sensor, gDict, True, iDate, hDate, activity)
                        break
            
    elif showTime == "site":
        if LISTOFSITES in gDict:
            sites = gDict[LISTOFSITES]
            mysite = doThis[showTime].lower()
            if mysite == "*":
                for site in sites:
                    showSite(site, gDict, iDate, hDate, activity)
            else:
                for site in sites:
                    if site.lower() == mysite:
                        showSite(site, gDict, iDate, hDate, activity)
            
        pass

    elif showTime == LOGGER:
        if LOGGER in gDict:
            logs = gDict[LOGGER]
            for log in logs:
                hrTime = datetime.datetime.fromtimestamp( float(log[LOGTIME])).strftime('%a %d-%m-%Y %H:%M:%S.%fZ')
                print hrTime, log[HACTION], "on", log[XDATE]
        pass

    elif showTime == "chronology":
        if LOGGER in gDict:
            logs = gDict[LOGGER]
            tdic = {}
            nl = 0
            for log in logs:
                key = "{}_{}".format(log[TSTAMP], nl)
                tdic[key ]  = log
                nl += 1

            for logk in sorted(tdic.keys()):
                log = tdic[logk]
                hrTime = datetime.datetime.fromtimestamp( float(log[LOGTIME])).strftime('%a %d-%m-%Y %H:%M:%S.%fZ')
                print hrTime, log[HACTION], "on", log[XDATE]
        pass

    elif showTime == "detector":
        # we show information for a single detector in the form MOT720,TEMP
        # ie, 
        # for sensorID,detectorID or
        # for sensorID,*  or
        # for *,detectorID or 
        # for *,*
        mydet = doThis[showTime]
        (sensorId, detectorId) = mydet.split(",")
        if iDate is None:
            print "Info for {} ".format( mydet)
        else:
            print "Status for {} on {}".format( mydet, hDate)
        sensors = gDict[SENSORS]
        if sensorId == "*":
            if detectorId == "*":
                for sid in sensors.keys():
                    dets = sensors[sid][DETECTORS]
                    for det in dets.keys():
                        showDetector(sid,det, gDict, iDate, hDate, activity)
            else:
                for sid in sensors.keys():
                    dets = sensors[sid][DETECTORS]
#                    print dets
                    if detectorId not in dets:
                        print "Beep... {} not a valid detector".format(detectorId)
                    showDetector(sid,detectorId, gDict, iDate, hDate, activity)
                pass
        else:
            if sensorId not in sensors:
                print "Beep... {} not a valid sensor".format(sensorId)
                sys.exit
            if detectorId == "*":
                sid = sensors[sensorId]
                dets = sid[DETECTORS]
#                print dets
                for det in dets.keys():
                    showDetector(sensorId,det, gDict, iDate, hDate, activity)
            else:
                dets = sensors[sensorId][DETECTORS]
#               print dets
                if detectorId not in dets:
                    print "Beep... {} not a valid detector".format(detectorId)
                showDetector(sensorId,detectorId, gDict, iDate, hDate, activity)
                pass
        pass
    elif showTime == "pair":
        if PAIRS in gDict:
            pairs = gDict[PAIRS]
            mypair = doThis[showTime]
            if mypair == "*":
                for pair in sorted(pairs.keys()):
                    showPair(pair, gDict, iDate, hDate)
                pass
            else:
                for pair in sorted(pairs.keys()):
                    if mypair.lower() == pair.lower():
                        showPair(pair, gDict, iDate, hDate)
                pass

    elif showTime == "activity":
        # show the active period for an asset or all assets if no argument
        # is given
        pass
    elif showTime == "operational":
        # show those assets which are operational either "today" or at the
        # specified date
        (dkey, revKey) = revert(["detector"])
        if iDate is None:
            hDate = heute
            iDate = stime2utime(hDate)
        if PAIRS not in gDict:
            print "#Nothing to do. Sorry"
            sys.exit()

        pairs = gDict[PAIRS]
        mypair = doThis[showTime]
        pcount = 1
        for pair in sorted(pairs.keys()):
            tev = histoire(hDate,"test", HSTATUS, "undef");
            status = getStatus(tev, pairs[pair][HISTORY])
            (siteId, sensorId) = pair.split("|")
            leSite = gDict[SITES][siteId]
            leSensor = gDict[SENSORS][sensorId]
            siteStatus = getStatus(tev, leSite[HISTORY])
            shist = leSensor[HISTORY]
            sensorStatus = getStatus(tev, shist)
            if (status != "on") or (siteStatus != "on") or (sensorStatus != "on"):
                continue
            longi = gDict[SITES][siteId][SITELON]
            lati  = gDict[SITES][siteId][SITELAT]
            dets = leSensor[DETECTORS]
            d3 = []
            for detname in dets:
                det = dets[detname]
                chist = []
                for sh in shist:
                    chist.append(sh)
                deth = det[HISTORY]
                for dh in deth:
                    insert(dh, chist)
                detStatus = getStatus(tev, chist)
                print det[revKey["name"]], detStatus
                if detStatus != "on":
                    continue
                d3.append("{}:{}:{}".format(det[revKey["name"]],
                        det[revKey["unit"]], det[revKey["ucd"]]) )
            print "{}:{},{},{},{},{},{},{}".format(siteId,sensorId,
            lati,longi, pcount, "Time", sensorStatus, "|".join(d3))
#            operational(pair, gDict, iDate, hDate)
            pcount += 1
        pass
    else:
        print "unrecognised operation: ", showTime

    sys.exit()

def identifyStatus(asset, history, stvalue, fDate, tDate, verbus):
    """
    Rescue periods in which the status component equals stvalue
    """
#    print asset, history
    first = False
    intervals = []
    pair = []
    for h in history:
        th = h[TSTAMP]

        sth = h[HSTATUS]
        if verbus:
            print asset, fDate, h[TSTAMP], tDate, sth
        if sth == stvalue:
            pair = []
            pair.append(th)
            first = True
        else:
            if first:
                pair.append(th)
                intervals.append(pair)
                first = False
    for i in intervals:
        if i[0] < fDate:
            if i[1] < fDate:
                continue
            else:
                i[0] = fDate
        if i[0] > tDate:
            if i[1] > tDate:
                continue
            else:
                i[1] = tDate
        elif i[1] > tDate:
            i[1] = tDate
        t0 = datetime.datetime.fromtimestamp( int(i[0])).strftime('%d-%m-%Y')
        t1 = datetime.datetime.fromtimestamp( int(i[1])).strftime('%d-%m-%Y')
#        print i[0], i[1]
        print asset, t0, t1, stvalue


def do_identifyStatus(gDict, args):
    """
    Function to show periods in which an asset has a given status
    """
#    if len(args) == 0:
#        do_showHelp(gDict, ["identify"])
    (doThis, todo) = splitArgs(args, 2)
    fail = checkPresence(doThis, [CLSTATUS], ["sensor","site","pair", "detector"])
    if fail["truth"]:
        sys.exit()

    
    asset = todo[0]
    if CLSTATUS in doThis:
        status = doThis[CLSTATUS]
    else:
        print "No status has been specified"
        sys.exit()
    iDate = None
    hDate = None
    activity = False
    y3k   = stime2utime("10-01-3000")
#    print "maintenant: ", maintenant
    if "from" in todo:
        fDateH = doThis["from"]
    else:
        fDateH = "01-01-2000"
    fDate = stime2utime(fDateH)
    if "to" in todo:
        tDateH = doThis["to"]
    else:
        tDateH = heute
    if "verbose" in todo:
        verbose = True
    else:
        verbose = False
    tDate = stime2utime(tDateH)

    if "activity" in todo:
        activity = True


    if asset == "sensor":
        if LISTOFSENSORS in gDict:
            sensors = gDict[LISTOFSENSORS]
            print "sensors list: ", sensors
            mysensor = doThis[asset]
            if mysensor == "*":
                theSensors = sensors
            else:
                if mysensor in sensors:
                    theSensors = [ mysensor ]
                else:
                    print mysensor, "is not recognised as a sensor"
                    sys.exit()
            for sensor in theSensors:
                identifyStatus(sensor, gDict[SENSORS][sensor][HISTORY],
                            status, fDate, tDate, verbose)
#                showSensor(sensor, gDict, False, iDate, hDate, activity)
            
    elif asset == "site":
        if LISTOFSITES in gDict:
            sites = gDict[LISTOFSITES]
            mysite = doThis[asset]
            if mysite == "*":
                theSites = sites
            else:
                if mysite in sites:
                    theSites = [ mysite ]
                else:
                    print mysite, "is not recognised as a site"
                    sys.exit()
            for site in sites:
#                showSite(site, gDict, iDate, hDate, activity)
                identifyStatus(site, gDict[SITES][site][HISTORY],
                            status, fDate, tDate, verbose)
            
        pass

    elif asset == "detector":
        # we show information for a single detector in the form MOT720,TEMP
        # ie, 
        # for sensorID,detectorID or
        # for sensorID,*  or
        # for *,detectorID or 
        # for *,*
        mydet = doThis[asset]
        (sensorId, detectorId) = mydet.split(",")
        if iDate is None:
            print "Info for {} ".format( mydet)
        else:
            print "Status for {} on {}".format( mydet, hDate)
        sensors = gDict[SENSORS]
        if sensorId == "*":
            if detectorId == "*":
                for sid in sensors.keys():
                    dets = sensors[sid][DETECTORS]
                    shist = gDict[SENSORS][sid][HISTORY]
                    for det in dets.keys():
#                        showDetector(sid,det, gDict, iDate, hDate, activity)
                        dHist = []
                        for h in shist:
                            dHist.append(h)
                        for h in gDict[SENSORS][sid][DETECTORS][det][HISTORY]:
                            insert(h, dHist)
                        identifyStatus("{}.{}".format(sid,det),
                                dHist, status, fDate, tDate, verbose)
            else:
                for sid in sensors.keys():
                    shist = gDict[SENSORS][sid][HISTORY]
                    dets = sensors[sid][DETECTORS]
#                    print dets
                    if detectorId not in dets:
                        print "Beep... {} not a valid detector".format(detectorId)
                    dHist = []
                    for h in shist:
                        dHist.append(h)
                    for h in gDict[SENSORS][sid][DETECTORS][detectorId][HISTORY]:
                        insert(h, dHist)
#                    showDetector(sid,detectorId, gDict, iDate, hDate, activity)
                    identifyStatus("{}.{}".format(sid,detectorId),
                            dHist, status, fDate, tDate, verbose)
                pass
        else:
            if sensorId not in sensors:
                print "Beep... {} not a valid sensor".format(sensorId)
                sys.exit
            shist = gDict[SENSORS][sensorId][HISTORY]
            if detectorId == "*":
                sid = sensors[sensorId]
                dets = sid[DETECTORS]
#                print dets
                for det in dets.keys():
                    dHist = []
                    for h in shist:
                        dHist.append(h)
                    for h in gDict[SENSORS][sensorId][DETECTORS][det][HISTORY]:
                        insert(h, dHist)
#                    showDetector(sensorId,det, gDict, iDate, hDate, activity)
                    identifyStatus("{}.{}".format(sensorId,det),
                             dHist, status, fDate, tDate, verbose)
            else:
                dets = sensors[sensorId][DETECTORS]
#               print dets
                if detectorId not in dets:
                    print "Beep... {} not a valid detector".format(detectorId)
                dHist = []
                for h in shist:
                    dHist.append(h)
                for h in gDict[SENSORS][sensorId][DETECTORS][detectorId][HISTORY]:
                    insert(h, dHist)
#               showDetector(sensorId,detectorId, gDict, iDate, hDate, activity)
                identifyStatus("{}.{}".format(sensorId,detectorId),
                    dHist, status, fDate, tDate, verbose)
                pass
        pass
    elif asset == "pair":
        if PAIRS in gDict:
            pairs = gDict[PAIRS]
            mypair = doThis[asset]
            if mypair == "*":
                for pair in sorted(pairs.keys()):
#                    showPair(pair, gDict, iDate, hDate)
                    identifyStatus(pair,
                        gDict[PAIRS][pair],
                        status, fDate, tDate, verbose)
                pass
            else:
                for pair in sorted(pairs.keys()):
                    if mypair.lower() == pair.lower():
#                        showPair(pair, gDict, iDate, hDate)
                        identifyStatus(pair,
                            gDict[PAIRS][pair],
                            status, fDate, tDate, verbose)
                pass

    else:
        print "unrecognised operation: ", asset

    sys.exit()

def revert(objectList):
    if len(objectList) > 1:
        name = "-".join(objectList)
#        print "RevName: ", name
        if name not in revTemplate:
            ognil = {}
            dcle = {}
            for ol in objectList:
                lingo = templateObjs[ol]
                for l in lingo:
                    for k in l.keys():
                        ognil[ l[k] ] = k
                        dcle[k] = l[k]
            revTemplate[name] = ognil
            dirTemplate[name] = dcle
#            print "RevName: ", name, ognil
            pass
        
#        for objectd in objectList:
    else:
        name = objectList[0]
        if name not in revTemplate:
            lingo = templateObjs[name]
            ognil = {}
            dcle = {}
            for l in lingo:
                for k in l.keys():
                    ognil[ l[k] ] = k
                    dcle[k] = l[k]
            revTemplate[name] = ognil
            dirTemplate[name] = dcle
#            print "RevName: ", name, ognil
    return dirTemplate[name], revTemplate[name]

def showDetector(sensorId,detectorId, gDict, limitUstamp, hDate, activity):
    det = gDict[SENSORS][sensorId][DETECTORS][detectorId]
    status = ""

    dkey, vale = revert(["detector"])
#    print vale
    unit = "[{}]".format(det[vale["unit"]])
#    error = "{:.2f}".format(float(det["epsilon"]))
    error = det[vale["epsilon"]]
    dpair = "{}.{}".format(sensorId, detectorId)
    shist = gDict[SENSORS][sensorId][HISTORY]
    chist = []
    for h in shist:
        chist.append(h)
    for h in  det[HISTORY]:
        insert(h, chist)
    if limitUstamp is None:
        print "{:15s} {:8s} +/- {:8s} {:8s} {:8s}".format(dpair, unit,
                error, det[vale["ucd"]], status)
        print "{}'s history:".format(dpair)
#        print sensor, ms, HISTORY
        showHist({HACTION:"Action", HSTATUS:"Status"}, None)
        for ch in chist:
            showHist(ch, limitUstamp)
        pass
    else:
        tev = histoire(hDate,"test", HSTATUS, "undef");
        status = getStatus(tev, chist)
        print "{:15s} {:8s} +/- {:8s} {:8s} {:8s}".format(dpair, unit,
                error, det[vale["ucd"]], status)

def showPair(pair, gDict, limitUstamp, hDate):
    lePair = gDict[PAIRS][pair][HISTORY]
    if not liveAt(lePair, limitUstamp):
        print pair, "not active"
        return
    print "Pair ", pair #, lePair, limitUstamp
    showHist({HACTION:"Action", HSTATUS:"Status"}, None)
    pairs = gDict[PAIRS]
    for hist in lePair:
        showHist(hist, limitUstamp)


def cleanDict(obj):
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
#                print "ka:", k
                cleanDict(v)
            else:
                if k == "uid":
                    print 'ack!! %s : %s' % (k, v)
                    del obj[k]
                else: 
#                    print '%s : %s' % (k, v)
                    pass
    elif type(obj) == list:
#        print obj
        for v in obj:
            if hasattr(v, '__iter__'):
                cleanDict(v)
            else:
#                print "v is", v
                pass
    else:
#        print "o is", obj
        pass



#def do_addSite(fields, gDict, args):
#    """
#    Function to collect data about a site from stdin
#    """
#    site = {}
##    print "addSite - Things to extract ", fields
#    for f in fields:
#        while  True:
#            fname = raw_input("\t" + handles[f] + ": ")
#            if len(fname) > 0:
#                site[f] = fname
#                break
#    appendSite(site)


def appendSite(site, kv):
#    print "KV: ", kv
#    print "VK: ", vk
    firstDate = kv["firstdate"]
    if site[firstDate] == "today":
        site[firstDate] =  time.strftime(idf)

    sepoch = time.mktime(datetime.datetime.strptime(site[firstDate], idf).timetuple())
    sdft =  site[firstDate]
#    sdu = str(datetime.datetime(int(sd[2]), int(sd[1]), int(sd[0])))
    sdu = stime2utime(sdft)
#    print "sdu = ", sdu, " utime: ", sepoch
    site[kv["epoch.f"]] = sepoch
    site[kv["date.l"]] = "01-01-3000"
#    fd =  site["date.l"].split("/")
#    fdu = str(datetime.datetime(int(fd[2]), int(fd[1]), int(fd[0])))
    fdu = stime2utime(site[kv["date.l"]])
    site[kv["epoch.l"]] = fdu
#    site[kv["username"]] = uname
    site[HISTORY] = []
#    stamp = [ sdu , sdft, "activated"]
    opera = kv["operator"]
    if opera in site:
        operator = site[opera]
        if "|" in operator:
            parts = operator.split("|")
            obi = {}
            for p in parts:
                k_v = p.split(":")
                obi[k_v[0]] = k_v[1]
            site[opera] = obi
        else:
            site[opera] = { "id" : operator}
        
#    if "sensoridee" in site:
#        if site["sensorid"] != "-":
#            sensors = site["sensorid"].split("|")
#            site["sensorid"] = sensors
#            site[HISTORY].append([sdu, sdft, "pairedWith", site["sensorid"] ])
#    print "SITE: ", site

    seatid = kv["siteid"]
    sid = site[seatid]
    if SITES not in gDict:
        gDict[SITES] = {}
    if LISTOFSITES not in gDict:
        gDict[LISTOFSITES] = []
    if sid in gDict[SITES]:
        msg = "overwriteSite"
    else:
        gDict[LISTOFSITES].append(sid)
        msg = "addSite"

    gDict[SITES][sid] = site
#    event = [ time.time(), str(datetime.datetime.now()), msg, [sid] ]
    event = histoire(sdft, "{} {}".format(msg,sid), XDATE, sdft)
    gDict[LOGGER].append(event)
    print "{} site {} on {}".format(msg,sid, sdft)
    stamp = histoire(sdft, "operational", HSTATUS, "deployed")
    site[HISTORY].append(stamp)
    if msg == "addSite":
        stamp = histoire("01-01-3000","decommissioned", HSTATUS, "dead");
        site[HISTORY].append(stamp)
#    print gDict
#    for k in sorted(site.keys()):
#        if k in vk:
#            print "{:20s} : {} ({})".format(vk[k], site[k], k)
#        else:
#            print "{:20s} : {} ({})".format(k, site[k], k)



def checkArgs(args, nmandatory):
    if len(args) < nmandatory:
        do_showHelp(gDict, [laAction])


def do_addSitesFromFile(gDict, args):
    """
    Function to collect data about a site from stdin
    """
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["file"], [])
    if fail["truth"]:
        sys.exit()

        
    fileName = fail["file"] # todo[0]
    if not os.path.isfile(fileName):
        print fileName, " does not exist. Quiting"
        sys.exit()


    dfile = open(fileName,"r")
    lines = dfile.read().splitlines()
    dfile.close()
#    print "Number of lines: ", len(lines)
    dkey, walkeyrie = revert(["site"])

#    knldg = templateObjs["site"]
#    keyWal = {}
#    for k in knldg:
##        print k
#        for cle in k.keys():
#            keyWal[cle] = k[cle]
#            walkeyrie[ k[cle] ] = cle

    site = {}
    for line in lines:
        if len(line) < 2:
            continue
        if line == "begin.asset":
            pass
        elif line != "end.asset":
            kv = line.split("=")
            k0 = kv[0]
            if k0 in walkeyrie:
                site[ walkeyrie[k0] ] = kv[1]
            else:
                site[ k0 ] = kv[1]
        else:
            appendSite(site, walkeyrie)
            site = {}

    # temporary exit to avoid 
#    print "c'est fini"
#    sys.exit()

def do_createTemplate(gDict, args):
    """
    Function to create input templates for sensors and sites
    """
#    checkArgs(args, 1)
#    print actionsHelp["getInputTemplate"]["Args"]
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["type"], [])
    kind = fail["type"] # todo[0]
    if fail["truth"]:
        print kind, " makes no sense"
        sys.exit()
    n = 1
    if "n" in doThis:
        n = int(doThis["n"])
#    kind = args.pop(0)
    if kind != "sensor" and kind != "site":
        print kind, " must be either sensor or site"
        sys.exit()

#    fields = templateArgs[kind]
    fields = templateObjs[kind]
#    print "# template for ", kind
    examples = {
        "operator" : "id:xx|contact:xx|tel:xxxyyyyzzz|email:xxx@yyy",
        "provider" : "id:xx|contact:xx|tel:xxxyyyyzzz|email:xxx@yyy",
        "firstdate": "DD-MM-YYYY",
        "energysupply": "solar|mains",
    }
    hide = ["listOfDetectors", "detector", "epoch.f", "date.l", "epoch.l", "history", "username"]
    for i in range(0,n):
        print "begin.asset"
        for uf in fields:
            uk = uf.keys()
            for f in uk:
                uff = uf[f]
                if uff in hide:
                    continue
                if uff == "n-detectors":
                    print "# add more detectors if necessary"
                    for i in range(0,5):
                        print "detector=name:xxx|unit:xx|epsilon:xx"
                    break
                if uff in examples:
                    print "{}={}".format(uff, examples[uff])
                else:
                    print "{}=".format(uff)
        print "end.asset\n"
    sys.exit()

#def do_addSensor(fields, gDict, args):
#    """
#    Function to collect data about a sensor from stdin
#    """
#    sensor = {}
##    print "addSite - Things to extract ", fields
#    for f in fields:
#        while  True:
#            fname = raw_input("\t" + handles[f] + ": ")
#            if len(fname) > 0:
#                sensor[f] = fname
#                break
#    nq = int(sensor["nquantities"])
#    quant = {}
#    lquant  = []
#    print "Enter measured quantities as: name|units|uncertainty|UCD"
#    for i in range(0,nq):
#        qtty = raw_input("\t quantity" + str(i) + ": ")
#        qs = qtty.split("|")
#        qN = qs[0]
#        qU = qs[1]
#        qE = qs[2]
#        qZ = qs[3]
#        lquant.append(qN)
#        obi = { "units" : qU , "uncertainty": qE, "UCD" : qZ, HISTORY: []}
#
#        quant[qN] = obi
#        
##    print "\n\n"
##    print sensor
#
#    sensor[DETECTORS] = quant
#    sensor[LISTOFDETECTORS] = lquant
#    appendSensor(sensor)

def appendSensor(sensor, kv):
    firstdate = kv["firstdate"]
    if sensor[firstdate] == "today":
        sensor[firstdate] =  time.strftime(idf)

    sepoch = time.mktime(datetime.datetime.strptime(sensor[firstdate], idf).timetuple())
    sdft =  sensor[firstdate]
#    sdu = str(datetime.datetime(int(sd[2]), int(sd[1]), int(sd[0])))
    sdu = stime2utime(sdft)
#    print "sdu = ", sdu, " utime: ", sepoch
    sensor[kv["epoch.f"]] = sepoch
    sensor[kv["date.l"]] = "01-01-3000"
#    fd =  sensor["date.l"].split("/")
#    fdu = str(datetime.datetime(int(fd[2]), int(fd[1]), int(fd[0])))
    fdu = stime2utime(sensor[kv["date.l"]])
    sensor[kv["epoch.l"]] = fdu
#    sensor[kv["username"]] = uname
    sensor[HISTORY] = []
#    stamp = [ sdu , "activated"]
#    event = histoire(None, msg, "id", sid)
    stamp = histoire(sdft,"commisioned", HSTATUS, "hold");
    sensor[HISTORY].append(stamp)
    stamp = histoire("01-01-3000","decommisioned", HSTATUS, "off");
    sensor[HISTORY].append(stamp)

    lesDetectors = sensor[DETECTORS]
    for det in sorted(sensor[DETECTORS].keys()):
#        print type(det), det, lesDetectors[det]
        lesDetectors[det][HISTORY] = []
#    sys.exit()

    prova = kv["provider"]
    if prova in sensor:
        provider = sensor[prova]
        if "|" in provider:
            parts = provider.split("|")
            obi = {}
            for p in parts:
                k_v = p.split(":")
                obi[k_v[0]] = k_v[1]
            sensor[prova] = obi
        else:
            sensor[prova] = { "id" : provider}
#    print sensor

    sid = sensor[kv["sensorid"]]
    if SENSORS not in gDict:
        gDict[SENSORS] = {}
    if LISTOFSENSORS not in gDict:
        gDict[LISTOFSENSORS] = []
    if sid in gDict[SENSORS]:
        msg = "overwriteSensor"
    else:
        gDict[LISTOFSENSORS].append(sid)
        msg = "addSensor"
    gDict[SENSORS][sid] = sensor
#    gDict[LISTOFSENSORS].append(sid)
#    event = [ ctime, str(datetime.datetime.now()), msg, [sid] ]
    event = histoire(sdft, "{} {}".format(msg,sid), XDATE, sdft)
#    print "{} sensor {} {}".format(msg,sid, sdft)
    gDict[LOGGER].append(event)

    # for test purposes only:
#    print sensor
#    for k in sorted(sensor.keys()):
#        if k in vk:
#            print "{:30s}={} ({})".format(vk[k], sensor[k], k)
#        else:
#            print "{:30s}={} ({})".format(k, sensor[k], k)

def do_addSensorsFromFile(gDict, args):
    """
    Function to collect data about sensors from a file
    """

#    checkArgs(args, 1)
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["file"], [])
    if fail["truth"]:
        sys.exit()

    fileName = doThis["file"]
    if not os.path.isfile(fileName):
        print fileName, " does not exist. Quiting"
        sys.exit()

    dkey, walkeyrie = revert(["sensor","detector"])
#    keyWal = {}
#    knldg = templateObjs["sensor"]
#    for k in knldg:
#        for cle in k.keys():
#            keyWal[cle] = k[cle]
#            walkeyrie[ k[cle] ] = cle
#
#    knldg = templateObjs["detector"]
#    for k in knldg:
#        for cle in k.keys():
#            keyWal[cle] = k[cle]
#            walkeyrie[ k[cle] ] = cle

    dfile = open(fileName,"r")
    lines = dfile.read().splitlines()
    dfile.close()
#    print "Number of lines: ", len(lines)
    sensor = {}
    lquant  = []
    quant = {}
    sensorid = "undef"
    for line in lines:
        if len(line) < 2:
            continue
        if "#" in line:
            continue
        if line == "end.asset":
            if "detector" in sensor:
                del sensor["detector"]
            sensor[DETECTORS] = quant
            sensor[LISTOFDETECTORS] = lquant
            appendSensor(sensor, walkeyrie)

            sensor = {}
            lquant  = []
            quant = {}
        elif line == "begin.asset":
            pass
        else:
#            print line
            k_v = line.split("=")
            k0 = k_v[0]
            k1 = k_v[1]
            if k0 == "sensorid":
                sensorid = k1
            if k0 == "detector":
                qs = k1.split("|")
                obi = {}
                for qq in qs:
                    qt = qq.split(":")
                    obi[walkeyrie[ qt[0] ] ] = qt[1]
#                    print "measure split: ", qt[0], qt[1]
                qN = obi[walkeyrie["name"]]
                obi[ walkeyrie["ucd"] ] = getUCD(qN, sensorid)
                lquant.append(qN)
                quant[qN] = obi
            else:
                sensor[walkeyrie[k0]] = k1
    # temporary, for testing purposes
#    sys.exit()

def getUCD(name, sensor):
    ucd = None
    for k in ucds.keys():
        if name in ucds[k]:
#            print "Got it: {} is {}".format(name, k)
            ucd = k
            break
    if ucd is None:
        print "Warning, *{}.{}* could not be assigned a known UCD".format(sensor, name)
    return ucd


def do_activateSensorInSite(gDict, args):
    """
    Function to attach a sensor to a site
    """
#    checkArgs(args, 3)
    (doThis, todo) = splitArgs(args, 3)
    fail = checkPresence(doThis, ["sensor", "site", "date"], [])
    if fail["truth"]:
        sys.exit()


    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    date = doThis["date"]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
                            "activating")

    fdu = stime2utime(date)
    if PAIRS not in gDict:
        print "Pair sensor/site is not present. Doing nothing"
        sys.exit()
#        gDict[PAIRS] = {}
    pairs = gDict[PAIRS]
    tag = "{}|{}".format(siteKey, sensorKey)
    print "Taking: {} at {} ({}) live on: {} ".format(sensorid,siteid,tag,date)
    if tag not in pairs:
        pairs[tag] = []
    tev = histoire(date,"running", HSTATUS, "on");

    insert(tev, pairs[tag][HISTORY])

#    stamp = [ tev[TSTAMP] , "attached to {}".format(siteKey)]
#    gDict[SENSORS][sensorKey][HISTORY].append(stamp)
    insert(tev, gDict[SENSORS][sensorKey][HISTORY])
    msg = "{} activated at {}".format(sensorKey, siteKey)
    event = histoire(date, msg, XDATE, date)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} activated".format(sensorKey), HSTATUS, "on");
    insert(tev, shist)

def historian(gDict, date, **kwargs):
    if not kwargs:
        print "No arguments given. Nothing to do."
    for a in kwargs:
        options[a.lower()] = kwargs[a]
    siteId = None
    sensorId = None
    detectorId = None


def getSenSite(gDict, sensorid, siteid, date, what):
    sites = gDict[SITES]
    sensors = gDict[SENSORS]
    siteKey = None
    sensorKey = None
    leSite = None
    leSensor = None
    for site in sites.keys():
#        print site, siteid, sites[site]
#        sid = sites[site]["siteid"]
        if site.lower() == siteid:
#            print "site", site, siteid, " located"
            siteKey = site
            leSite = sites[site]
            break
            
    for sensor in sensors.keys():
#        print sensor, sensorid
#        sid = sensors[sensor]["sensorid"]
        if sensor.lower() == sensorid:
#            print "sensor", sensor, " located"
            sensorKey = sensor
            leSensor = sensors[sensor]
            break
            
    if sensorKey is None:
        print "Invalid sensor: ", sensorid
    if siteKey is None:
        print "Invalid site: ", siteid

    # We need to require that both site and sensor are active at the time
    # point of attachement
    siteDate = leSite[HISTORY][0][TSTAMP]
    sensorDate = leSensor[HISTORY][0][TSTAMP]

#    print "site   date: ", siteDate
#    print "sensor date: ", sensorDate
    if sensorDate < siteDate:
        print "Causality violation while {}. Quiting. {} newer than {}".format(what, siteid, sensorid)
        sys.exit()

    return (siteKey, sensorKey)

def do_attachSensorToSite(gDict, args):
    """
    Function to attach a sensor to a site
    """
#    checkArgs(laAction, args, 3)
#    checkArgs(args, 4)
    (doThis, todo) = splitArgs(args, 4)
    fail = checkPresence(doThis, ["sensor","site", "hag", "date"], [])
    if fail["truth"]:
        sys.exit()
    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    hag = doThis["hag"]
    date = doThis["date"]
    ucSiteId = lcDict["sites"][siteid]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
    "attaching")

    fdu = stime2utime(date)
    if PAIRS not in gDict:
        gDict[PAIRS] = {}
    pairs = gDict[PAIRS]
    tag = "{}|{}".format(siteKey, sensorKey)
    print "pairing: ", sensorid, siteid, date, fdu, "as", tag
    if tag not in pairs:
        pairs[tag] = {"ph":hag, HISTORY:[]}
#    else:
#        print tag, "already a valid pair"
#        sys.exit()
    tev = histoire(date,"attach", HSTATUS, "active");
    insert(tev, pairs[tag][HISTORY])

    tev = histoire(date,"attached to {}".format(ucSiteId), HSTATUS, "active");
    insert(tev, gDict[SENSORS][sensorKey][HISTORY])
    msg = "{} installed at {}".format(sensorKey, siteKey)
    event = histoire(date, msg, XDATE, date)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} attached".format(sensorKey), HSTATUS, "att");
    insert(tev, shist)


def insert(stamp, aList):
    """
    Function to insert a time stamp defined by "histoire()" into a list of
    these elements so that the list is always time sorted
    """
    nTime = stamp[TSTAMP]
    lSize = len(aList)
#    print "List size", lSize
#    print aList
#    print aList[0]
    if lSize == 0:
        aList.append(stamp)
        end = histoire("01-01-3000","theEnd", HSTATUS, "dead")
        aList.append(end)
    else:
        top = lSize - 1
        for i in range(0,top):
            if nTime >= aList[i][TSTAMP] and nTime < aList[i+1][TSTAMP]:
#                print "insertion point: " , i, stamp
                aList.insert(i+1,stamp)
                break

#def do_showSensorSite(gDict, args):
#    """
#    Function to examine the history of a sensor/site pair
#    """
#    checkArgs("activatesensorinsite", args, 3)
##    if len(args) < 3:
##        print "Invalid syntax, try:"
##        print execute, "detachSensorsFromSite sensorID siteID DD/MM/YYYY"
##        sys.exit()
#    sensorid = args[0].lower()
#    siteid = args[1].lower()
#    date = args[2]
#
#    sites = gDict[SITES]
#    sensors = gDict[SENSORS]
#    siteKey = None
#    sensorKey = None
#    for site in sites.keys():
#        sid = sites[site]["siteid"]
#        if sid.lower() == siteid:
#            print "site", sid, " located"
#            siteKey = site
#            
#    for sensor in sensors.keys():
#        sid = sensors[sensor]["sensorid"]
#        if sid.lower() == sensorid:
#            print "sensor", sid, " located"
#            sensorKey = sensor
#            
#    if sensorKey is None:
#        print "Invalid sensor: ", sensorid
#    if siteKey is None:
#        print "Invalid site: ", siteid
#    pairs = gDict[PAIRS]
#    tag = "{}|{}".format(siteKey, sensorKey)
#    if tag not in pairs:
#        print "Combination not in the dictionary: ", tag
#        sys.exit()
#    print "examining: ", sensorid, siteid, date, tag
#    tev = histoire(date,"test", HSTATUS, "undef");
#    status = getStatus(tev, pairs[tag])
#    print tag, "@", date, status

def getStatus(eve, things):
    nThings = len(things)
#    print "List size", nThings
    if nThings == 0:
#        print "Nothing to examine, sorry!"
        return "undef"
    else:
        top = nThings - 1
#        print "length of things: ", nThings, top
#        print things
        nTime = eve[TSTAMP]
        for i in range(0,top):
            thing = things[i]
            hrTime = datetime.datetime.fromtimestamp( int(thing[TSTAMP])).strftime('%Y-%m-%d')
#            print thing[HACTION], hrTime
            if nTime >= things[i][TSTAMP] and nTime < things[i+1][TSTAMP]:
#                print "insertion point: " , i, "status: ", things[i][HSTATUS]
                return things[i][HSTATUS]
#                break

def do_detachSensorFromSite(gDict, args):
    """
    Function to detach a sensor from a site
    """
#    checkArgs(args, 3)
    (doThis, todo) = splitArgs(args, 3)
    fail = checkPresence(doThis, ["sensor","site", "date"], [])
    if fail["truth"]:
        sys.exit()
    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    date = doThis["date"]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
                "detacching")


    fdu = stime2utime(date)
    if PAIRS not in gDict:
        print "No pairs have been defined yet. Doing nothing"
        sys.exit()
#        gDict[PAIRS] = {}
    pairs = gDict[PAIRS]
    tag = "{}|{}".format(siteKey, sensorKey)
    print "Detaching: ", sensorid, siteid, date, fdu, tag
    if tag not in pairs:
        # this should be an error, it should not be possible to detach a
        # sensor from a non-existent pair
        print "{} is not a valid pair. Doing nothing".format(tag)
        sys.exit()
#        pairs[tag] = []
    tev = histoire(date,"detach", HSTATUS, "off");
    insert(tev, pairs[tag][HISTORY])
    # modify the sensor's general history
    insert(tev, gDict[SENSORS][sensorKey][HISTORY])

    msg = "{} detached from {}".format(sensorKey, siteKey)
    event = histoire(date, msg, XDATE, date)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} detached".format(sensorKey), HSTATUS, "kaput");
    insert(tev, shist)

def lcClone(gDict):
    lcd = {}
    if SITES in gDict:
        lcd["sites"] = {}
        lcds = lcd["sites"]
        for sk in gDict["sites"].keys():
            lcds[sk.lower()] = sk

    if PAIRS in gDict:
        lcd[PAIRS] = {}
        lcdp = lcd[PAIRS]
        for sk in gDict[PAIRS].keys():
            lcdp[sk.lower()] = sk
        pass
    if SENSORS in gDict:
        lcd["sensors"] = {}
        lcd["detectors"] = {}
        lcdz = lcd["sensors"]
        lcdd = lcd["detectors"]
        for sk in gDict["sensors"].keys():
            ld = gDict["sensors"][sk]["ld"]
            lcz = sk.lower()
            lcdz[lcz] = sk
            for d in ld:
                lcdd["{}.{}".format(lcz, d.lower())] = d
    return lcd

#  End of the function definitions
#  main code starts here

if os.path.isfile(assetsFile):
    dfile = open(assetsFile,"r")
    jsonString = dfile.readline().rstrip('\n')
#    print jsonString
    gDict = json.loads(jsonString)
#    gDict = json.load(dfile.read())
    lcDict = lcClone(gDict)
#    print "Alt-dict", lcDict
    dfile.close()
else:
    gDict = {}
#    gDict[LISTOFSITES] = []
#    gDict[SITES] = {}
#    gDict[LISTOFSENSORS] = []
#    gDict[SENSORS] = {}
    gDict[LOGGER] = []


functions = {}
# the next two functions are being deprecated as of Dec 7, 2017  PH+76
# functions["addsite"] = do_addSite;
# functions["addsensor"] = do_addSensor;

# allows to add data for a list of sites stored on a file in the form of
# key-value pairs (one per line). There is no restriction as to the
# elements to go into the dictionary, but a few are mandatory
functions["addsitesfromfile"] = do_addSitesFromFile;

# ditto for sensor boxes
functions["addsensorsfromfile"] = do_addSensorsFromFile;

# Records in the PAIRS and in the "site" history the installation of a sensor
# box in a given site. Note that this action does not mean that the detectors
# or the sensor as a whole are marked as producing reliable data.
# In fact, there can be a gap of several days between the date of the
# installation and the time in which reliable data starts being gathered.
# The sensor/site entry is marked with  "status=active"
functions["attachsensortosite"] = do_attachSensorToSite;

# Records in the PAIRS and "site" history that a sensor has started
# gathering reliable data at a given date.
# The sensor/site entry is marked with  "status=on"
functions["activatesensorinsite"] = do_activateSensorInSite;

# Records in the PAIRS and "site" history that a sensor has been removed
# from a "site" at a certain date.
# The sensor/site entry is marked with  "status=off"
functions["detachsensorfromsite"] = do_detachSensorFromSite;

# Add information to several assets
functions["addinfo"] = do_addInfo;
# Remove information from several assets: history entries and fields.
functions["rminfo"] = do_rmInfo;

# All previous functions alter the dictionary and rewrite a new version.

# The functions below do not alter the dictionary, they only examine its
# current content
#functions["showdictionary"] = do_showDictionary;
functions["show"] = do_showThings;
functions["help"] = do_showHelp;
functions["getinputtemplate"] = do_createTemplate;
functions["identify"] = do_identifyStatus;
#functions["showsensorsite"] = do_showSensorSite;


theActions = sorted(functions.keys())
args = sys.argv
executable = args.pop(0)
ex = executable.split("/")
execute = ex.pop()
nargs = len(args)

if nargs == 0:
    print "Usage: uam <action> <args>"
    print "  where action can be any of:"
#    for a in sorted(actionsHelp):
    for a in helpOrder:
        b = a.lower()
        if b in functions:
            mark = ""
        else:
            mark = "[TODO]"
        aha = actionsHelp[a]
        print "   ", mark, a, aha["args"], "\n\t", aha["short"]
    sys.exit()

uname = getpass.getuser()
laAction = args[0]
args.pop(0)
#print "dealing with action", laAction
lcname = laAction.lower()
#print "the action is: ", laAction , " --> ", lcname

laKey = None
for key in actionsHelp.keys():
   if lcname == key.lower():
       laKey = key
       break
if laKey is None:
    print lcname, "is not a valid action. Please fix"
    print lcname, "NSA: No Such Action"
    sys.exit()
#functions[lcname](arguments[lcname], gDict, args)
if lcname not in functions:
    print lcname, "NSA: No Such Action"
    sys.exit()
functions[lcname](gDict, args)

cleanDict(gDict)
assetsLog = open(assetsFile,'w')
assetsLog.write(json.dumps(gDict))
assetsLog.close()

backup = "{}_{}".format(assetsFile, stamp)
assetsBU = open(backup,'w')
assetsBU.write(json.dumps(gDict))
assetsBU.close()


sys.exit()

#extractData(name, entries, gDict)


# The idea would be to have a system to generate functions to gather data
# based on the HACTION requested rather than having code split in
# different actions.
# At return point, these functions should put the data in the global object 

# Let's give it a try to this


#p = '%Y-%m-%dT%H:%M:%S.%fZ'
#p2 = '%Y-%m-%dT%H:%M:%SZ'
#utcf = '%Y-%m-%dT%H:%M:%S'
#
#
#def stringArray(origList):
#    """
#        Routine to return an array of numpy characters of shape
#        (len(list), maxLen) as well as the number of elements in the list
#        and the maximum length of the strings in the list
#    """
#    maxlen = 0
#    for s in origList:
#        if len(s) > maxlen:
#            maxlen = len(s)
#    listLen = len(origList)
#    charMatrix = np.empty((listLen, maxlen), dtype='a1')
#    charMatrix.fill(" ")
#
#    i = 0
#    for s in origList:
#        sarray = np.array(list(s), dtype='a1')
#        sLen = len(s)
#        charMatrix[i,0:sLen] = sarray[:]
##        if sLen < maxlen:
##            charMatrix[i,sLen] = 0
##        if sLen+1 < maxlen:
##        charMatrix[i,sLen:-1] = " "
#        i += 1
#
#    return charMatrix, listLen, maxlen
#
##def extractStrings(cMatrix, indices):
##    """
##        Routine to return an subset of the lines stored in the cMatrix
##        array. Details in of the incoming matrix need to be extracted at
##        run-time rather than passed (just in case)
##    """
##    nXelements = len(indices)
##    print "Elements to extract: ", nXelements
##    print cMatrix.shape
##    return
##    maxlen = 0
##    for s in origList:
##        if len(s) > maxlen:
##            maxlen = len(s)
##    listLen = len(origList)
##    charMatrix = np.empty((listLen, maxlen), dtype='a1')
##    charMatrix.fill(" ")
##
##    i = 0
##    for s in origList:
##        sarray = np.array(list(s), dtype='a1')
##        sLen = len(s)
##        charMatrix[i,0:sLen] = sarray[:]
##        i += 1
##
##    return charMatrix, listLen, maxlen
#
## get arguments from the command line to avoid having to edit this program
## all the time!
#nargs = len(sys.argv)
#if nargs < 1:
#    print "Usage: ", sys.argv[0], " csv-file [-validate]"
#    sys.exit()
#
#print "Nargs ", nargs
#
#mytime = "2017-03-08T00:27:31.807Z"
#epoch = datetime(1970, 1, 1)
##print((datetime.strptime(mytime, p) - epoch).total_seconds())
#
#csvFile = sys.argv[1]
#validate = False
#if nargs == 3 and sys.argv[2] == "-validate":
#    validate = True
#
#fileDate = csvFile.replace(".csv","")
##ncdfFile = "../binary/" + csvFile.replace("csv","nc")
#ncdfFile = csvFile.replace("csv","nc")
#
##column = int(sys.argv[2])
##msd = {'co': 0, 'pm25': 1, 'pm10': 2, 'so2': 3, 'bc': 4,
##'o3': 5 , 'no2': 6}
#msd = {}
#places = {}
#stdPlaces = []
#internal_place_id = {}
#measured = {}
#qperplace = {}
#qpertime = {}
#compo = {}
#invalid = {}
#skip = []
#skip.append(0)
#uniqueSiteTime = {}
#sitesWithWrongUnits = {}
#pollutants = {}
#d_epoque = {}
#d_siteInternal = {}
#meta_sites = {}
#meta_city = []
#meta_country = []
#meta_longitude = []
#meta_latitude = []
#meta_attributes = []
#meta_dtz = []
#meta_site = []
#good_lines = []
##meta_city = []
#mainId = []
#
#lSiteId = []
#lSensorId = []
#lTimeStamp = []
#lCO = []
#lNO = []
#lNO2 = []
#lRH = []
#lTemp = []
#lBat = []
#lNoise = []
#lDate = []
#dayDict = {}
#monDict = {}
#
#file = open(csvFile, 'r') 
#nLines = 0
#for row in file:
## siteId (char array)
## sensorId (integer)
## timeStamp (integer)
## Carbon Monoxide
## Nitric Oxide
## Nitrogen Dioxide
## Relative Humidity
## Temperature
## Battery
## Noise
#
##    print row
#
#    siteId, sensorId, tstamp, uxTime, co, no, no2, rhum, temp, bat, noise = row.rstrip().split()
#    lSiteId.append(siteId)
#    lSensorId.append(int(sensorId))
#    lTimeStamp.append(int(uxTime))
#    lCO.append(float(co))
#    lNO.append(float(no))
#    lNO2.append(float(no2))
#    lRH.append(float(rhum))
#    lTemp.append(float(temp))
#    lBat.append(float(bat))
#    lNoise.append(float(noise))
#    date, hour = tstamp.split("T")
#    year, month, day = date.split("/")
#    mond = '{}/{}'.format(year, month)
#    lDate.append(tstamp)
#    dayDict[date] = 1
#    monDict[mond] = 1
#    nLines += 1
##    print siteId, sensorId, tstamp
#
#print "Number of lines: ", nLines
#novalue = -32768
#
## data is already ingested, so it is time to create the big datafile.
#sarrSiteId, nst, lenSites = stringArray(lSiteId)
#print "Number of lines: ", nst, lenSites
#
#print "first site: ", sarrSiteId[0]
#print "Months found: ", monDict.keys()
##print "Days found: ", dayDict.keys()
#
#for bino in sorted(monDict.keys()):
#    dino = bino.replace("/", "-")
##    indices = np.where(bino in lDate)
#    print "Selecting: ", bino, " / ", dino, " "
#    indices = [i for i,s in enumerate(lDate) if bino in s]
#
##    print indices
##    sDate = [lDate[i] for i in indices]
##    break
#    leFile = "{}.nc".format(dino)
#    dbFile = Dataset(leFile, 'w', format='NETCDF4_CLASSIC')
#    dbFile.createDimension('data_nDataPoints', len(indices))
#    dbFile.createDimension('md_sitesLen', lenSites)
#    
#    dsiteId = dbFile.createVariable('siteId', 'S1', ('data_nDataPoints','md_sitesLen'), zlib=True)
#    dsiteId.comment = 'Site Identifier'
#    
#    
#    dataEpoch = dbFile.createVariable('dataEpoch', 'i4', ('data_nDataPoints',),zlib=True)
#    dataEpoch.comment = "Unix Epoch for each observation to the second"
#    dataEpoch.units = 'seconds since 1970, Jan 1, 00:00:00 UTC'
#    
#    # By using an internal integer index we're supposed to speed things up in
#    # the searching. There is really no need to have a long string as the key
#    # if an integer will do!
#    dataSensorId = dbFile.createVariable('dataSensorId', 'i4', ('data_nDataPoints',),zlib=True)
#    dataSensorId.comment = "Sensor-id. ID associated with the sensor, not where it is located"
#    
#    # Now we must define the variables associated to the particles, this is
#    # goint to be dynamic
#    
#    xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#        "battery", "NoiseLevel"]
#    
#    data_co = dbFile.createVariable("CO", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_co.comment = "Air concentration of Carbon Monoxide"
#    data_co.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    data_no = dbFile.createVariable("NO", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_no.comment = "Air concentration of Nitric Oxide"
#    data_no.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    data_no2 = dbFile.createVariable("NO2", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_no2.comment = "Air concentration of Nitrogen Dioxide"
#    data_no2.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#        "battery", "NoiseLevel"]
#    
#    data_rhum = dbFile.createVariable("RelativeHumidity", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_rhum.comment = "Air Relative Humidity"
#    data_rhum.unit = "Percentage (%)"
#    
#    data_temp = dbFile.createVariable("AirTemperature", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_temp.comment = "Air Relative Humidity"
#    data_temp.unit = "Celcius (C)"
#    
#    data_battery = dbFile.createVariable("Battery", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_battery.comment = "Battery level"
#    data_battery.unit = "Volt"
#    
#    data_noise = dbFile.createVariable("NoiseLevel", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_noise.comment = "Noise Level"
#    data_noise.unit = "Decibels"
#    
##    sDate = [lDate[i] for i in indices]
#    dataSensorId[:] = [lSensorId[i] for i in indices]
#    dataEpoch[:] =    [lTimeStamp[i] for i in indices]
#    data_co[:] =      [lCO[i] for i in indices]
#    data_no[:] =      [lNO[i] for i in indices]
#    data_no2[:] =     [lNO2[i] for i in indices]
#    data_rhum[:] =    [lRH[i] for i in indices]
#    data_temp[:] =    [lTemp[i] for i in indices]
#    data_battery[:] = [lBat[i] for i in indices]
#    data_noise[:] =   [lNoise[i] for i in indices]
#    dsiteId[:] = [sarrSiteId[i] for i in indices]
##    dsiteId[:] = extractStrings(sarrSiteId, indices)
#    
#    dbFile.close()
#    print leFile, " created"
#
#for bino in sorted(dayDict.keys()):
#    dino = bino.replace("/", "-")
##    indices = np.where(bino in lDate)
#    print "Selecting: ", bino, " / ", dino, " "
#    indices = [i for i,s in enumerate(lDate) if bino in s]
#
##    print indices
##    sDate = [lDate[i] for i in indices]
##    break
#    leFile = "{}.nc".format(dino)
#    dbFile = Dataset(leFile, 'w', format='NETCDF4_CLASSIC')
#    dbFile.createDimension('data_nDataPoints', len(indices))
#    dbFile.createDimension('md_sitesLen', lenSites)
#    
#    dsiteId = dbFile.createVariable('siteId', 'S1', ('data_nDataPoints','md_sitesLen'), zlib=True)
#    dsiteId.comment = 'Site Identifier'
#    
#    
#    dataEpoch = dbFile.createVariable('dataEpoch', 'i4', ('data_nDataPoints',),zlib=True)
#    dataEpoch.comment = "Unix Epoch for each observation to the second"
#    dataEpoch.units = 'seconds since 1970, Jan 1, 00:00:00 UTC'
#    
#    # By using an internal integer index we're supposed to speed things up in
#    # the searching. There is really no need to have a long string as the key
#    # if an integer will do!
#    dataSensorId = dbFile.createVariable('dataSensorId', 'i4', ('data_nDataPoints',),zlib=True)
#    dataSensorId.comment = "Sensor-id. ID associated with the sensor, not where it is located"
#    
#    # Now we must define the variables associated to the particles, this is
#    # goint to be dynamic
#    
#    xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#        "battery", "NoiseLevel"]
#    
#    data_co = dbFile.createVariable("CO", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_co.comment = "Air concentration of Carbon Monoxide"
#    data_co.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    data_no = dbFile.createVariable("NO", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_no.comment = "Air concentration of Nitric Oxide"
#    data_no.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    data_no2 = dbFile.createVariable("NO2", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_no2.comment = "Air concentration of Nitrogen Dioxide"
#    data_no2.unit = "micro-grams per cubic meter [mu-g/m^3]"
#    
#    xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#        "battery", "NoiseLevel"]
#    
#    data_rhum = dbFile.createVariable("RelativeHumidity", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_rhum.comment = "Air Relative Humidity"
#    data_rhum.unit = "Percentage (%)"
#    
#    data_temp = dbFile.createVariable("AirTemperature", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_temp.comment = "Air Relative Humidity"
#    data_temp.unit = "Celcius (C)"
#    
#    data_battery = dbFile.createVariable("Battery", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_battery.comment = "Battery level"
#    data_battery.unit = "Volt"
#    
#    data_noise = dbFile.createVariable("NoiseLevel", 'f4',
#        ('data_nDataPoints',),zlib=True, fill_value=novalue)
#    data_noise.comment = "Noise Level"
#    data_noise.unit = "Decibels"
#    
##    sDate = [lDate[i] for i in indices]
#    dataSensorId[:] = [lSensorId[i] for i in indices]
#    dataEpoch[:] =    [lTimeStamp[i] for i in indices]
#    data_co[:] =      [lCO[i] for i in indices]
#    data_no[:] =      [lNO[i] for i in indices]
#    data_no2[:] =     [lNO2[i] for i in indices]
#    data_rhum[:] =    [lRH[i] for i in indices]
#    data_temp[:] =    [lTemp[i] for i in indices]
#    data_battery[:] = [lBat[i] for i in indices]
#    data_noise[:] =   [lNoise[i] for i in indices]
#    dsiteId[:] = [sarrSiteId[i] for i in indices]
##    dsiteId[:] = extractStrings(sarrSiteId, indices)
#    
#    dbFile.close()
#    print leFile, " created"
#
#sys.exit()
#print "Creating netcdf file: ", ncdfFile
#
#
#dbFile = Dataset(ncdfFile, 'w', format='NETCDF4_CLASSIC')
#dbFile.createDimension('data_nDataPoints', nLines)
#dbFile.createDimension('md_sitesLen', lenSites)
#
#dsiteId = dbFile.createVariable('siteId', 'S1', ('data_nDataPoints','md_sitesLen'), zlib=True)
#dsiteId.comment = 'Site Identifier'
#
#
#dataEpoch = dbFile.createVariable('dataEpoch', 'i4', ('data_nDataPoints',),zlib=True)
#dataEpoch.comment = "Unix Epoch for each observation to the second"
#dataEpoch.units = 'seconds since 1970, Jan 1, 00:00:00 UTC'
#
## By using an internal integer index we're supposed to speed things up in
## the searching. There is really no need to have a long string as the key
## if an integer will do!
#dataSensorId = dbFile.createVariable('dataSensorId', 'i4', ('data_nDataPoints',),zlib=True)
#dataSensorId.comment = "Sensor-id. ID associated with the sensor, not where it is located"
#
## Now we must define the variables associated to the particles, this is
## goint to be dynamic
#
#xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#    "battery", "NoiseLevel"]
#
#data_co = dbFile.createVariable("CO", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_co.comment = "Air concentration of Carbon Monoxide"
#data_co.unit = "micro-grams per cubic meter [mu-g/m^3]"
#
#data_no = dbFile.createVariable("NO", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_no.comment = "Air concentration of Nitric Oxide"
#data_no.unit = "micro-grams per cubic meter [mu-g/m^3]"
#
#data_no2 = dbFile.createVariable("NO2", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_no2.comment = "Air concentration of Nitrogen Dioxide"
#data_no2.unit = "micro-grams per cubic meter [mu-g/m^3]"
#
#xcompo = ["co", "no", "no2", "RelativeHumidity", "Temperature",
#    "battery", "NoiseLevel"]
#
#data_rhum = dbFile.createVariable("RelativeHumidity", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_rhum.comment = "Air Relative Humidity"
#data_rhum.unit = "Percentage (%)"
#
#data_temp = dbFile.createVariable("AirTemperature", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_temp.comment = "Air Relative Humidity"
#data_temp.unit = "Celcius (C)"
#
#data_battery = dbFile.createVariable("Battery", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_battery.comment = "Battery level"
#data_battery.unit = "Volt"
#
#data_noise = dbFile.createVariable("NoiseLevel", 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue)
#data_noise.comment = "Noise Level"
#data_noise.unit = "Decibels"
#
#dsiteId[:] = sarrSiteId
#dataSensorId[:] =     lSensorId
#dataEpoch[:] =     lTimeStamp
#data_co[:] =     lCO
#data_no[:] =     lNO
#data_no2[:] =     lNO2
#data_rhum[:] =     lRH
#data_temp[:] =     lTemp
#data_battery[:] =     lBat
#data_noise[:] =     lNoise
#
#dbFile.close()
#
#sys.exit()
#
#with open(csvFile, mode='r') as infile:
#    reader = csv.reader(infile)
#    lesRows = list(reader)
#    nrows = len(lesRows)
#    print nrows, len(lesRows)
#
#    for row in lesRows:
## siteId (char array)
## sensorId (integer)
## timeStamp (integer)
## Carbon Monoxide
## Nitric Oxide
## Nitrogen Dioxide
## Relative Humidity
## Temperature
## Battery
## Noise
#        print row
#        siteId, sensorId, tstamp, uxTime, co, no, no2, rhum, temp, bat, noise = row[0].split()
#        print siteId, sensorId
#    sys.exit()
#
##    dmat = np.zeros( (nrows ,8), np.float )
##    dmat.fill(-32768)
##    print dmat
#    nrows = 0
#    nWrongDate = 0
#    nWrongUnit = 0
##    for row in reader:
#    duplicated = {}
#    duplicatedValue = {}
#    siteCounter = 0
#    for row in lesRows:
## siteId (char array)
## sensorId (integer)
## timeStamp (integer)
## Carbon Monoxide
## Nitric Oxide
## Nitrogen Dioxide
## Relative Humidity
## Temperature
## Battery
## Noise
#        siteId, sensorId, tstamp, uxTime, co, no, no2, rhum, temp, bat, noise = row[:]
#        if nrows > 0:
#            # form a key with lat/lon + location-city-country
##            print row[8], row[9]
#            # ignore entries without lat/lon data
#            site, city, country, zulu, loct, comp, vcomp, unit, lat, lon, ass = row[:]
##            print site, city, country, zulu, loct, comp, vcomp, unit, lat, lon, ass , row
##            siteId =  "{:s}|{:s}|{:s}".format( site, city, country)
#            siteId =  "{:s}|{:s}|{:s}".format( country.lower(),
#                    city.rstrip().lower(), site.rstrip().lower())
##            dkey = "{:s} {:s} {:s} {:s}".format(lat, lon, zulu  ,comp)
#            epoque = (datetime.strptime(zulu, p) - epoch).total_seconds()
#            uniqueSiteTS = "{} {}".format(epoque  ,siteId)
#            dkey = "{} {} {}".format(siteId, epoque  ,comp)
#            if (lat == "" or lon == "") or \
#               (float(lat) == 0.0 or float(lon) == 0.0):
##                print "Invalid row: ", row
#                invalid[siteId] = 1
#                skip.append(nrows)
#            elif dkey in duplicated:
#                duplicated[dkey] += 1
#                duplicatedValue[dkey].append(row[6])
#                skip.append(nrows)
#            elif "ppm" in unit:
#                nWrongUnit += 1
#                sitesWithWrongUnits[site] = "{} {} {} {}".format(site,
#                                            city, country, unit)
#                skip.append(nrows)
#            elif fileDate not in zulu:
##                print uniqueSiteTS, zulu
#                nWrongDate += 1
#                skip.append(nrows)
#            else:
#                duplicated[dkey] = 1
#                duplicatedValue[dkey] = []
#                duplicatedValue[dkey].append(row[6])
#                compo[comp] = 1
#                uniqueSiteTime[uniqueSiteTS] = 1
#                # and to do the on-spot validation instead of using another
#                # script:
#
#                good_lines.append(row)
#
#                # ready to store data so that we can retrieve it to form
#                # both the metadata and the data of the netcdf file
#
#                # this is the metadata part...
#                if siteId not in meta_sites:
#                    meta_sites[siteId] = siteCounter
#                    mainId.append(siteCounter)
#                    meta_site.append( site)
#                    meta_city.append( city)
#                    meta_country.append( country)
#                    meta_longitude.append( float(lon))
#                    meta_latitude.append( float(lat))
#                    meta_attributes.append( ass)
#                    sdtime = loct[19:]
#                    hours, minutes = sdtime.split(":")
#                    dtime = float(hours)
#                    if "-" in hours:
#                        dtime -= float(minutes)/60.
#                    else:
#                        dtime += float(minutes)/60.
#                    meta_dtz.append( dtime)
#                    siteCounter += 1
#
#                # this is the data part...
#                if comp not in pollutants:
#                    pollutants[comp] = {}
#                pollutants[comp][uniqueSiteTS] = vcomp
#                d_epoque[uniqueSiteTS] = epoque
#                d_siteInternal[uniqueSiteTS] = meta_sites[siteId]
#        nrows += 1
#
#    xcompo = sorted(compo.keys())
#    print "dict of particles: ", compo
#    print "List of particles: ", xcompo
#    peq = 0
#    for com in xcompo:
#        msd[com] = peq
#        peq += 1
#    print "new dict of particles: ", msd
#
#    print "Sites without Lon/lat", len(invalid.keys())
##    for site in sorted(invalid.keys()):
##        print "Invalid Lat/Lon: ", site
#
#    print "sites with ppm as unit:", len(sitesWithWrongUnits.keys())
##    for site in sorted(sitesWithWrongUnits.keys()):
##        print "wrong Unit site: ", site, sitesWithWrongUnits[site]
#
#    for dup in duplicated.keys():
#        if duplicated[dup] > 1:
#            print "Duplicated entry: ", dup, duplicated[dup], duplicatedValue[dup]
#
#    # to see if the first part is OK
#    print "Rows to skip: ", len(skip), nrows
#    print "NRows with wrong date: ", nWrongDate, nrows
#    print "NRows with wrong units: ", nWrongUnit, nrows
#nDataPoints =  len(uniqueSiteTime.keys())
#print "Nummer of unique site/time combos: ", len(uniqueSiteTime.keys())
#
#novalue = -32768
#
#pdict = {}  # the data dictionary, keys are pollutants, values are numpy arrays
#            # initialised to novalue
#
#sortedUniqueEntries = sorted(uniqueSiteTime.keys())
#
#pos = 0
#dEpoque = np.zeros( (nDataPoints ), np.int )
#dSiteId =  np.zeros( (nDataPoints ), np.int )
#dEpoque.fill(-32768)
#dSiteId.fill(-32768)
#
## initialise the pollutants arrays
#for pol in xcompo:
#    pdict[pol] = np.zeros( (nDataPoints ), np.float )
#    pdict[pol].fill(-32768)
#
#for sue in sortedUniqueEntries:
#    dSiteId[pos] = d_siteInternal[sue]
#    dEpoque[pos] = d_epoque[sue]
#    for pol in xcompo:
#        if sue in pollutants[pol]:
#                pdict[pol][pos] = pollutants[pol][sue]
#    pos += 1
#
#
##print meta_site
#print "Number of cities: ", len(meta_site)
#
## we should be able to put everything into arrays and then pass it onto
## the file writer.
#
##                    meta_site.append( site)
##                    meta_city.append( city)
##                    meta_country.append( country)
##                    meta_attributes.append( ass)
##                    sdtime = loct[19:]
##                    hours, minutes = sdtime.split(":")
##                    dtime = float(hours)
##                    if "-" in hours:
##                        dtime -= float(minutes)/60.
##                    else:
##                        dtime += float(minutes)/60.
##                    meta_dtz.append( dtime)
##                    meta_longitude.append( float(lon))
##                    meta_latitude.append( float(lat))
#print "Sanity check for id: ", len(mainId), len(meta_site)
##sarrMainKey, nStations, lenMainKey = stringArray(mainKey)
#sarrSites, nStations, lenSites = stringArray(meta_site)
#sarrCities, nst, lenCities = stringArray(meta_city)
#sarrCountries, nst, lenCountries = stringArray(meta_country)
#sarrAttributes, nst, lenAttributes = stringArray(meta_attributes)
##sarrSiteKey, nPoints, maxSiteLen = stringArray(siteKey)
##sarrSiteId, nPoints, maxSiteIdLen = stringArray(leSiteId)
#
##sarrCites = np.empty((nst, 40), dtype='a1')
##
##i = 0
##for s in cities:
##        sarray = np.array(list(s), dtype='a1')
###        sLen = len(s)
##        sarrCites[i,0:len(s)] = sarray[:]
##        sarrCites[i,len(s):-1] = " "
##        i += 1
#
#print "NsiteKeys: ", len(mainId)
#print "N-Stations: ", nStations, nst
#print "N-datapoints: ", nDataPoints
#print "Max len cities: ", lenCities
#print "Max sites len: ", lenSites
#print "Max attributes len: ", lenAttributes
#
#
#print "Creating netcdf file: ", ncdfFile
#dbFile = Dataset(ncdfFile, 'w', format='NETCDF4_CLASSIC')
#dbFile.createDimension('md_nStations', nStations)
#dbFile.createDimension('data_nDataPoints', nDataPoints)
##dbFile.createDimension('md_keyLen', lenMainKey)
#dbFile.createDimension('md_sitesLen', lenSites)
#dbFile.createDimension('md_cityLen', lenCities)
#dbFile.createDimension('md_countryLen', lenCountries)
#dbFile.createDimension('md_attributeLen', lenAttributes)
#dsite = dbFile.createVariable('md_site', 'S1', ('md_nStations','md_sitesLen'), zlib=True)
#dsite.comment = 'Site name, as provided in the original data-files'
#
##dsiteKey = dbFile.createVariable('md_siteKey', 'S1', ('md_nStations','md_keyLen'), zlib=True)
##dsiteKey.comment = 'Site key, common for both tables'
#
#dsiteid = dbFile.createVariable('md_siteId', 'i4', ('md_nStations'), zlib=True)
#dsiteid.comment = 'Internal site ID for this file only'
#
#latitude = dbFile.createVariable('md_latitude', 'f4', ('md_nStations',), zlib=True)
#latitude.units = 'degree_north'
#latitude.comment = 'Latitude as given in the original data'
#
#longitude = dbFile.createVariable('md_longitude', 'f4', ('md_nStations',), zlib=True)
#longitude.units = 'degree_east'
#longitude.comment = 'Longitude as given in the original data'
#
#dtimez = dbFile.createVariable('md_TZ-ZULU', 'f4', ('md_nStations',), zlib=True)
#dtimez.comment = 'Difference of local time respect to GMT'
#dtimez.units = "Decimal hours"
#
#dcityKey = dbFile.createVariable('md_city', 'S1', ('md_nStations','md_cityLen'), zlib=True)
#dcityKey.comment = 'City name (but it could be province, state, or other'
#
#dcountry = dbFile.createVariable('md_country', 'S1', ('md_nStations','md_countryLen'), zlib=True)
#dcountry.comment = 'Two letter country code'
#
##sarrAttributes, nst, lenAttributes = stringArray(attributes)
#datts = dbFile.createVariable('md_attributes', 'S1', ('md_nStations','md_attributeLen'), zlib=True)
#datts.comment = 'Attributes as given by data provider'
#
## Define now the data variables
##datasiteKey = dbFile.createVariable('data_siteKey', 'S1', ('data_nDataPoints','md_keyLen'), zlib=True)
##datasiteKey.comment = 'Site key, values are common for both tables'
#
#dataEpoch = dbFile.createVariable('dataEpoch', 'i4', ('data_nDataPoints',),zlib=True)
#dataEpoch.comment = "Unix Epoch for each observation to the second"
#dataEpoch.units = 'seconds since 1970, Jan 1, 00:00:00 UTC'
#
## By using an internal integer index we're supposed to speed things up in
## the searching. There is really no need to have a long string as the key
## if an integer will do!
#dataSiteId = dbFile.createVariable('dataSiteId', 'i4', ('data_nDataPoints',),zlib=True)
#dataSiteId.comment = "site-id internal index, valid for this file only"
#
## Now we must define the variables associated to the particles, this is
## goint to be dynamic
#
#peq = 0
#cvars = []
#for com in xcompo:
#    cvars.append(dbFile.createVariable(com, 'f4',
#    ('data_nDataPoints',),zlib=True, fill_value=novalue))
#    cvars[-1].comment = "Air concentration of {:s}".format(com)
#    cvars[-1].unit = "micro-grams per cubic meter [mu-g/m^3]"
##    peq += 1
#
#
##dsiteKey = dbFile.createVariable('siteKeyMD', 'S1', ('keyLen', 'nStations'), zlib=True)
##latitude = dbFile.createVariable('latitude', 'f4', ('nStations',))
##longitude = dbFile.createVariable('longitude', 'f4', ('nStations',))
#dsite[:] = sarrSites
##                    meta_dtz.append( dtime)
##                    meta_longitude.append( float(lon))
##                    meta_latitude.append( float(lat))
#latitude[:] = meta_latitude
#longitude[:] = meta_longitude
#dtimez[:] = meta_dtz
##dsiteKey[:] = sarrMainKey
#dsiteid[:] = mainId
#dcityKey[:] = sarrCities
##dcityKey[:] = sarrCites
#dcountry[:] = sarrCountries 
#datts[:] = sarrAttributes
#
#dataEpoch[:] = dEpoque
#dataSiteId[:] = dSiteId
#
## closing before data are rearranged and written:
#
#col = 0
#for com in xcompo:
##    cvars[col][:] = dmat[:,col]
##    aa = dmat[:,col]
#    cvars[col][:] = pdict[com]
#    col += 1
#
#dbFile.close()
#
#
## we may want to do an immediate data verification, and for that we saved
## the participating lines and we will read the file one more time
#if not validate:
#    print "No validation/consistency/sanity-check will be performed now"
#    sys.exit()
#
## Let's open the file and then try to get the information we need...
#verFile = Dataset(ncdfFile, 'r')
#vdEpoch = verFile.variables["dataEpoch"][:]
#vdSiteId = verFile.variables['dataSiteId'][:]
#md_siteId = verFile.variables['md_siteId'][:]
#md_site = verFile.variables['md_site'][:]
#md_city = verFile.variables['md_city'][:]
#md_country = verFile.variables['md_country'][:]
#
#nsta = len(md_siteId)
#print "From the recently open file, nStations: ", nsta
#siteEquiv = {}
#for i in range(0, nsta):
#    site = ''.join(md_site[i]).rstrip()
#    city = ''.join(md_city[i]).rstrip()
#    country = ''.join(md_country[i]).rstrip()
#    key = '{:s}|{:s}|{:s}'.format(site, city, country)
#    siteEquiv[key] = md_siteId[i]
##    print "SCHK1", i, site, key, siteEquiv[key]
#
##sys.exit()
#
#print "About to validate the recently created file"
#nerrors = 0
#for row in good_lines:
#    site, city, country, zulu, loct, comp, vcomp, unit, lat, lon, ass = row[:]
#    epoque = (datetime.strptime(zulu, p) - epoch).total_seconds()
#    siteId =  "{:s}|{:s}|{:s}".format( site.rstrip(), city.rstrip(), country)
#    xsid = siteEquiv[siteId]
#    o_indx = np.where(np.logical_and(vdEpoch == epoque, vdSiteId == xsid))[0]
#    dcomp = verFile.variables[comp][o_indx[0]]
#    fcomp = float(vcomp)
##    if fcomp != dcomp:
#    dval = fcomp - dcomp
#    if abs(dval) > 1e-4:
#        parts = vcomp.split('.')
#        fmt = '{:.'+'{}'.format(len(parts[-1]))+'f}'
##        print parts, fmt
#        stPol = fmt.format(dcomp)
#        if stPol != vcomp:
#            print "ISOT: ", siteId, site, o_indx, comp, vcomp, stPol, dcomp, fcomp, dval
#            nerrors += 1
#
#print "Number of errors: ", nerrors
#sys.exit()
#
## These are pure data, and I'd like to arrange each of them according to
## sorted epoch, after all, we are dealing with a time based database, and
## time series extracted from the data as a per station, should have their
## timestamps sorted, and every data involved with it as well.
#
#nepoch = np.array(lepoch)
#sortInd = nepoch.argsort()
##sortedEpochIndices = np.array([i[0] for i in sorted(enumerate(lepoch), key=lambda x:x[1])])
#print "SortaInd: ", sortInd
#print min(lepoch) #, nepoch[sortInd[0]]
#print "Type(lepoch): ", type(lepoch)
#print "Type(nepoch): ", type(nepoch)
#
#sepoch = nepoch[sortInd]
#sid = np.array(leSiteId)
#print min(lepoch), max(lepoch)
#print sepoch
#
##dataEpoch[:] = lepoch
##dataSiteId[:] = leSiteId
#
##print "About shapes: "
##print "sortInd: ", np.shape(sortInd)
##print "cvars: ", np.shape(cvars)
##print "Going for the assignments "
#
#
#
#col = 0
#for com in xcompo:
##    cvars[col][:] = dmat[:,col]
#    aa = dmat[:,col]
#    cvars[col][:] = aa[sortInd]
#    col += 1
#dbFile.close()
#
#
