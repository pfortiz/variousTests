#! /usr/bin/env python

# Script to deal with the definition of assets (sites and sensors) in the
# Urban Flows Observatory, Sheffield.
#
# This code should help to build the database (command line oriented)
# It should also be capable to retrieve the state of all the assets at a
# certain time. This is the information which shall be fed to the
# web-interface for any particular point in the time-line.


# string timestamp not incorporated into binary file.
#
#UoS_AJ_702 100702 2016/10/30T00:05:08 1477782308 0.61 1.43 30.04 81.70 12.60 3.55 57.00
# as well as trying to get the content of an url into a file using urllib
from numpy import array
import numpy as np
import os
import sys
import time
import json
#import urllib
import csv

#
# This script is meant to be in the examples repository. 
#
# The next statement needs to be changed if it is copied somewhere else and
# the correct path to plotopy has to be provided.

plotopyPath = os.environ['PLOTOPY']
sys.path.append(plotopyPath)


import timeXtras  as tx

#print plotopyPath
import time
import datetime
import getpass

ctime =  time.time()
maintenant = ctime
#print ctime
alora = str(datetime.datetime.now())
dt = alora.split()
laDate = int(dt[0].replace("-", ""))
idf = "%d-%m-%Y";
idtf = '%d-%m-%YT%H:%M:%S'
heute = time.strftime("%d-%m-%Y")
#print alora, laDate, heute
hms = dt[1].split(":")
leTime = int(hms[0])/24.0 + float(hms[1])/1440. + float(hms[2])/86400;
#print "date", dt[0], laDate, " time ", dt[1], " fod", leTime
stamp = "{:.6f}".format(laDate + leTime)
#print "Stampo : ", stamp
epoch = datetime.datetime(1970, 1, 1)
#print "epoch = " , epoch
assetsFile = "/Users/Shared/ufloTables/assets.db"
lcDict = {}
hStat = {}
HISTORY = "h"
LOGGER = "log"
XDATE = "xdate"
SITES = "sites"
SENSORS = "sensors"
SENSORID = "za"
DETECTORS = "dk"
LISTOFDETECTORS = "ld"
LISTOFSENSORS = "lz"
LISTOFSITES = "ls"
SITELON = "slo"
SITELAT = "sla"
TSTAMP = "hT"
LOGTIME = "hL"
HACTION = "hA"
CLSTATUS = "status"
HSTATUS = "hS"
PAIRS = "pairs"

H_TSTAMP = 0
H_LSTAMP = 1
H_MESSGE = 2
H_STATUS = 3
H_USRNME = 4

L_TSTAMP = 0
L_LTIME  = 1
L_ACTION = 2
hLabel = [None, None, "Action", "Status"]

# Change this one if working on a project with a different starting date
time_offset = str(datetime.datetime(2015, 1, 1))
tOffsetDef = time.mktime(datetime.datetime.strptime(time_offset, "%Y-%m-%d %H:%M:%S").timetuple())



#print "Time offset: ", time_offset, tOffset

def alt_histoire(hstamp, action, key, value):
    hist = {}
#    hist["hrStamp"] = hstamp
    # hist[TSTAMP] = stime2utime(hstamp)
    if not hstamp is None:
        if "T" in hstamp:
            tfmt = idtf
        else:
            tfmt = idf
        hist[TSTAMP] = time.mktime(datetime.datetime.strptime(hstamp, tfmt).timetuple()) - tOffset
    hist[LOGTIME] = time.time() - tOffset
    hist[HACTION] = action
    if key != XDATE or hstamp != value:
        hist[key] = value
#    hist["hu"] = uname
    return hist

def histoire(hstamp, action, status):
    if hstamp is None:
        print "Timestamp is None???"
        h_t = None
    else:
        if "T" in hstamp:
            tfmt = idtf
        else:
            tfmt = idf
        h_t = time.mktime(datetime.datetime.strptime(hstamp, tfmt).timetuple()) - tOffset
    l_t = time.time() - tOffset
#    hist = [h_t, l_t, action, status, uname]
    hist = [h_t, l_t, action, status]
    return hist

def ulogger(hstamp, message):
    if not hstamp is None:
        if "T" in hstamp:
            tfmt = idtf
        else:
            tfmt = idf
        h_t = time.mktime(datetime.datetime.strptime(hstamp, tfmt).timetuple()) - tOffset
    else:
        h_t = None
    l_t = time.time() - tOffset
#    hist = [h_t, l_t, message, uname]
    hist = [h_t, l_t, message]
    return hist



actionsHelp = {
    "getInputTemplate": {
        "args":"type=<site|sensor> [n=N] [ > <input_file>]",
        "Args":{"m":["type"], "op":["n"], "mc":[] },
        "short": "Prints a template to stdout to enter sensor or site data from files. If 'n=X' is specified, X templates are produced.",
        "long":"""Generate one or more templates to enter sensor or site basic data.

You are advised to redirect the output to a filename for you to
edit and enter all information relative to that sensor/site.

Note that if you have other pieces of information not shown in the list,
just add them as key=value in extra lines."""
        },
    "addSitesFromFile": {
        "args":"file=input_file",
        "short":"Add a list of sites from a file",
        "long": """Enter a list of sites from a file.
  Template files can be obtained with:
    uam getInputTemplate site """
        },
    "closeSite": {
        "args":"site=siteid",
        "short":"Mark the site as closed",
        "long": """Mark a given site with status closed."""
        },
    "addSensorsFromFile": {
        "args":"file=filename", 
        "short":"Add a list of sensors from a file",
        "long":"""Add a list of sensors from data stored in a file. 
  Template files can be obtained with:
    uam getInputTemplate sensor"""
        },
    "attachSensorToSite": {
        "args":"sensor=sensorID site=siteID hag=height_above_ground_[m] date=DD-MM-YY ",
        "short":"Pair a sensor to a site at a given date",
        "long":"""Indicate when a sensor is physically attached into a site.
Data starts being collected but it is unreliable.
The height-above-ground is mandatory, and indicate the location of the
"sensor-box" with respect to the ground.
Use activateSensorInSite to mark the moment data from all sensors is reliable."""
        },
    "activateSensorInSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Indicate when reliable data gathering begins",
        "long":"""Mark when a sensor starts collecting reliable data"""
        },
    "deactivateSensorInSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Indicate when unreliable data gathering begins",
        "long":"""Mark when a sensor starts collecting data considered unreliable """
        },
    "detachSensorFromSite": {
        "args":"sensor=sensorID site=siteID date=DD-MM-YYYY ",
        "short":"Detach a sensor from a site at a specific date+time.",
        "long":"""Detach a sensor from a site at a specific date+time"""
        },
#    "addDetectorInformation": {
#        "args":"sensor=sensorID detector=measured-quantity <info> <date>",
#        "short":"Alter the status of data collection for an individual detector attached to a sensor.",
#        "long":"""As detectors can go rogue, this is a way to indicate when
#a detector has gone belly up or is back to normal.
#info=on   indicates a perfectly working detector
#info=anything-else indicates the detector is acting up and it will be used
#to avoid providing data for that detector while its status is not back to 'on'"""
#        },
    "deactivateSite": {
        "args":"<siteID> ",
        "short":"mark a site as decommissioned",
        "long":"""Mark a site as decommissioned """
        },
    "rminfo": {
        "args":"tag=history-tag",
        "short":"removes the entry pointed by 'history-tag' from the corresponding history entry",
        "long":"""Removes a history entry with the label 'history-tag'. 
'history-tag' shall be obtaining from the last column found when a history
is shown by the use of the 'show' option."""
        },
    "addinfo": {
        "args":"info=flag|field|maintenance [siteid=xxx] [sensorid=yyy] [detector=zzz] value=vvv msg='mmm' date=DD-MM-YYYY",
        "short":"adds information to assets at various levels",
        "long":"""addinfo allows to incorporate information to the dictionry at
several levels. The operations allowed are:
uam addinfo info=flag to either a site, a sensor or sensor's detector.
           This operation affects the status of a device.
           status=on indicates the asset is active, operational and collecting
                meaningful data. 
           status='whatever-else' will make data starting at that ponit not to
                be considered 'suitable for analysis'
uam addinfo info=field: allow for the inclusion of fields omitted at the moment of
           writing this software to any element. Date is ignored. If value
           is a comma separated list of words, a list is entered in the
           field.
uam addinfo info=log. Like flag, except that the status of an asset is not
           altered, but an item in the maintenance field of the asset is
           added. value TBD as of Nov-30,2017

?uam addinfo info=maintenance. Like flag, except that the status of an asset is not
           altered, but an item in the maintenance field of the asset is
           added. value TBD as of Nov-30,2017
"""
        },
#uam show sensor=<sensorid>|*   Show data for one sensor or all if * is used
#uam show site=<siteid>|*       Show data for a site or all if * is used
#uam show pair=<sensor,site>|*  Show data for a pair sensor + site
    "show": {
        "args": "element [date=x]",
        "short":"Show a particular database element now or at the specified date",
        "long":"""show allows you to examine different aspects of the data.
Valid entries are:
uam show asset=pattern[*]      Show assets identical to pattern or any in
                               which pattern is included if the '*' is used

uam show log                   Show the activity as it was entered
uam show chronology            Show the sequence of operations on sensors,
                               sites, etc
uam show dictionary            Show the whole data structure
uam show operational [date=x]      Show all active sites at date DD-MM-YYYY

?uam show activeSites date      Show all active sites at date DD-MM-YYYY
?uam show activeSensors date    Show all active sensors at date DD-MM-YYYY
?uam show activePairs date      Show all active sensor/site pairs at DD-MM-YYYY
        """
        },
    "help": {
        "args":"[<action>]",
        "short": "Show help for an action or in general.",
        "long":"""Show some help for a given action"""
        },
    "identify": {
        "args": "<asset> status=sss [from=DD-MM-YYYY] [to=DD-MM-YYYY] [verbose]",
        "short":"Show periods when status = sss for a given asset",
        "long":"""identify allows you to determine periods of time when the
status has a given value for various assets.
Valid usages are:
uam identify sensor=<sensorid>          Show equal status periods for a sensor
uam identify site=<siteid>              Show equal status periods for a site
uam identify pair=<sensorid,siteid>     Show equal status periods for a pair
uam identify detector=<sensorid,detid>  Show equal status periods for a detector

sensorid, siteid, detid can be replaced by * to show all occurances.
from= determines the earliest date to perform the search. Default: 01-01-2015
to= determines the latest date to perform the search. Default: today
If verbose is specified, all history entries are shown in addition"""
        },

    };

helpOrder = [
    "addSitesFromFile",
    "addSensorsFromFile",
    "getInputTemplate",
    "attachSensorToSite",
    "detachSensorFromSite",
    "activateSensorInSite",
#    "deactivateSensorInSite",
#    "deactivateSite",
    "identify",
    "addinfo",
    "rminfo",
    "show",
    "help",

    ];


# these are the fields the user is given in the template file.
# It would be better to have a translation table between what is presented
# to the human eye and what goes 
templateArgs = {
    "site" : [
        "siteid", "address", "city", "country", "zip", "lon", "lat",
        "hasl", "firstdate", "operator", "sensorid"
        ],
    "sensor" : [
        "sensorid", "provider",  "firstdate", "energysupply",
        "freqmaintenance", "family", "data-acquisition-period_[min]",
        "serialnumber", "ndetectors", 
        ],
}

templateObjs = {
    "site" : [
        {"sa":"siteid"},
        {"sb":"address"},
        {"sc":"city"},
        {"sd":"country"},
        {"se":"Postal_Code"},
#       { "sf":"height_above_ground_[m]"},
        {"sg":"height_above_sea_level_[m]"},
        {"sh":"firstdate"},
        {"si":"epoch.f"},
        {"sj":"date.l"},
        {"sk":"epoch.l"},
        {SITELON:"longitude_[deg]"},
        {SITELAT:"latitude_[deg]"},
        {"sn":"operator"},
        {"h":"history"},
        {"u":"username"},
        ],
    "detector" : [
        {"dn":"name"},
        {"du":"unit"},
        {"de":"epsilon"},
        {"dz":"ucd"},
    ],
    "sensor" : [
        {"za":"sensorid"},
        {"zb":"provider"}, 
        {"zc":"serialnumber"},
        {"zd":"energysupply"},
        {"ze":"freqmaintenance"},
        {"zf":"family"},
        {"zg":"data-acquisition-interval[min]"},
        {"zh":"detector"},
        {"zi":"firstdate"},
        {"zj":"epoch.f"},
        {"zk":"date.l"},
        {"zl":"epoch.l"},
        {"zz":"n-detectors"},
        {"h":"history"},
        {"ld":"listOfDetectors"},
        ],
}

revTemplate = {}
dirTemplate = {}

ucds = {
    "MET_TEMP" : ["Temp", "T", "Temperature"],
    "MET_RH" : ["RH", "RelHum", "RelativeHumidity"],
    "MET_AP" : ["Pressure", "AirPressure", "barometricpressure"],
    "AQ_NOISE" : ["Noise"],
    "AQ_CO" : ["CO"],
    "AQ_NO" : ["NO"],
    "AQ_NO2" : ["NO2"],
    "AQ_SO2" : ["SO2"],
}


def stime2utime(stime):
    if "T" in stime:
        fmt = idtf
    else:
        fmt = idf
    return time.mktime(datetime.datetime.strptime(stime, fmt).timetuple()) - tOffset

def histKiller(obj, tag):
    qtag = "{:.6f}".format(float(tag))
#    print "HK"
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
                if k == HISTORY:
                    i = 0
                    for h in v:
                        rtag = "{:.6f}".format(h[LOGTIME])
                        if rtag == qtag:
                            del v[i]
                        i += 1

                else:
                    histKiller(v, tag)
#            else:
#                if k == LOGTIME:
#                    if qtag == tag:
#                        print obj
#                        print '%s :-: %s vs %s' % (k, qtag, tag)
    elif type(obj) == list:
        for v in obj:
            if obj == HISTORY:
#                print "IH:", obj
                 pass
            if hasattr(v, '__iter__'):
                histKiller(v, tag)
            else:
                if v == TSTAMP:
                    print "V: ", v
    else:
        if obj == TSTAMP:
            print "O", obj


def historian(obj):
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
                if k == HISTORY:
                    print "IT:", k, v
                    for h in v:
                        print h

                else:
                    historian(v)
    elif type(obj) == list:
#        print "OL", obj
        for v in obj:
            if obj == HISTORY:
                print "IH:", obj
            if hasattr(v, '__iter__'):
                historian(v)
            else:
                if v == TSTAMP:
                    print "V: ", v
    else:
        if obj == TSTAMP:
            print "O", obj


def do_rmInfo(gDict, args):
    """
    Function to remove an entry from any of the history lists
    """

    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["tag"], [])
    if fail["truth"]:
        sys.exit()

    theInfo = fail["tag"]

    if theInfo == "history":
        prefix = "Usage: uam rminfo history"
        fail = checkPresence(doThis, ["histoid"], ["histoid"])
        if fail["truth"]:
            print prefix, "histoid=xxx.xxx"
            sys.exit()
        theTag = doThis["histoid"]
#        print "GDOr:", len( json.dumps(gDict) )
        odict = gDict.copy()
        histKiller(gDict, theTag)
#        print "GDMod:", len( json.dumps(gDict) )
        event = ulogger(heute, "entry {} rm(history).".format(theTag))

    elif theInfo == "field":
        fail = checkPresence(doThis, ["fname"],
                    ["sensorid", "siteid"])

        if fail["truth"]:
            print "Usage: uam rminfo field sensorid=xxx fname='mmm'"
            print "Usage: uam rminfo field siteid=xxx fname='mmm'"
            sys.exit()
        field = doThis["fname"]
        if "sensorid" in doThis:
            sensorId = doThis["sensorid"]
            if sensorId not in gDict[SENSORS]:
                print sensorId, "is not an existing sensor. Quiting"
                sys.exit()
            sensor = gDict[SENSORS][sensorId]

            if field in sensor:
                del sensor[field]
            else:
                print field, "not part of ", sensorId
                sys.exit()
            messy = "{} removed from sensor {}.".format(field, sensorId)
        elif "siteid" in doThis:
            siteId = doThis["siteid"]
            if siteId not in gDict[SITES]:
                print siteId, "is not an existing site. Quiting"
                sys.exit()
            site = gDict[SITES][siteId]
            if field in site:
                del site[field]
            else:
                print field, "not part of ", siteId
                sys.exit()
            messy = "{} removed from site {}.".format(field, siteId)
        event = ulogger(heute, messy)
    else:
        print theInfo, "is not a valid 'thing' to remove from an asset"
        sys.exit()
    pass
    gDict[LOGGER].append(event)
    print "GDfinal:", len( json.dumps(gDict) )
#    print gDict[LOGGER]
    sys.exit()

    pass

def do_addInfo(gDict, args):
    """
    Function to add information to an asset
    """

    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["info"], [])
    if fail["truth"]:
        sys.exit()

    theInfo = doThis["info"]
    dateForm = "date=DD-MM-YYY[Thh:mm:ss.s]"

    if theInfo == "flag":
        usg = "uam addinfo flag"
        prefix = "Usage: {}\n".format(usg)
        fail = checkPresence(doThis, ["msg", CLSTATUS, "date"],
                    ["sensorid", "siteid", "pairid", "detid"])
#        if ("sensorid" not in doThis) and ("siteid" not in doThis) and ("pairid" not in doThis) and ("detectorid" not in doThis):
        if fail["truth"]:
            print "{}: Change the status of a sensor/site/detector".format(usg)
            print "{} sensorid=xxx msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} siteid=xxx msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} pairid=sensorid:siteid msg='mmm' status=vvv {}".format(prefix,dateForm)
            print "{} detid=sensorid:det msg='mmm' status=vvv {}".format(prefix,dateForm)
            sys.exit()
        if "sensorid" in doThis:
            asset = fail["sensorid"]
        elif "siteid" in doThis:
            asset = fail["siteid"]
        elif "pairid" in doThis:
            asset = fail["pairid"]
        elif "detid" in doThis:
            asset = fail["detid"]

        if asset is None:
            sys.exit()
        assetId = asset["uid"]
        history = asset[HISTORY]
        msg = "{} {}".format(assetId, doThis["msg"])

        event = histoire(doThis["date"], doThis["msg"], doThis[CLSTATUS])
        insert(event, history)
        then = heute


    elif theInfo == "field":
        fail = checkPresence(doThis, ["fname", "fvalue"],
                    ["sensorid", "siteid", "pairid", "detid"])

        if fail["truth"]:
            print "Usage: uam addinfo field sensorid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field siteid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field pairid=xxx fname='mmm' fvalue=vvv"
            print "Usage: uam addinfo field detid=xxx fname='mmm' fvalue=vvv"
            sys.exit()
        if "sensorid" in doThis:
            asset = fail["sensorid"]
        elif "siteid" in doThis:
            asset = fail["siteid"]
        elif "pairid" in doThis:
            asset = fail["pairtid"]
        elif "detid" in doThis:
            asset = fail["detid"]
        if asset is None:
            sys.exit()
        assetId = asset["uid"]
        asset[doThis["fname"]] = doThis["fvalue"]
        msg = "{} = {} added to {}".format(doThis["fname"], 
                        doThis["fvalue"].replace(" ", "_"), assetId)
        then = heute
    elif theInfo == "maintenance":
        fail = checkPresence(doThis, ["sensorid", "msg", "value", "date"], [])
        if fail["truth"]:
            print "Usage: uam addinfo maintenance sensorid=xxx msg='mmm' value=vvv date=DD-MM-YYYY"
            sys.exit()
        
        sys.exit()
#
#   TO-DO
#
#        sensorId = doThis["sensorid"]
#        if sensorId not in gDict[SENSORS]:
#            print sensorId, "is not an existing sensor. Quiting"
#            sys.exit()
#        sensor = gDict[SENSORS][sensorId]
#        sensor[doThis["fname"]] = doThis["fvalue"]
#        msg = "{} = {} added to {}".format(doThis["fname"], 
#                        doThis["fvalue"], sensorId)
#        then = heute
#        msg = doThis["msg"]
#        event = histoire(doThis["date"], doThis["msg"], None)
#        insert(event, history)
        pass

    elif theInfo == "log":
        fail = checkPresence(doThis, ["msg", "date"], [])
        if fail["truth"]:
            print "Usage: uam addinfo log msg='mmm' date=DD-MM-YYYY"
            sys.exit()
        then = heute
        msg = doThis["msg"]
        event = ulogger(doThis["date"], doThis["msg"])
        insert(event, gDict[LOGGER])

        pass
    else:
        print theInfo, "is not a valid 'thing' to add to an asset"
        sys.exit()

    event = ulogger(then, msg)
    gDict[LOGGER].append(event)

def checkPresence(doit, mustHave, oneAtLeast):
    fmh = False
    answer = {}
    answer["truth"] = False
    answer["sensorid"] = None
    answer["siteid"] = None
    answer["pairid"] = None
    answer["detid"] = None
    answer["type"] = None
    for mh in mustHave:
        if mh not in doit:
            print "{}=x not defined".format(mh)
            fmh = True
        else:
            answer[mh] = doit[mh]
    if fmh:
        answer["truth"] =  True

    if set(oneAtLeast) != set(mustHave) and len(oneAtLeast) > 0:
        foal = False

        for mh in oneAtLeast:
            if mh in doit:
                foal = True
                ass_et = doit[mh]
                if mh == "sensorid":
                    answer[mh] = getSensor(ass_et)
                elif mh == "siteid":
                    answer[mh] = getSite(ass_et)
                elif mh == "pairid":
                    answer[mh] = getPair(ass_et)
                elif mh == "detid":
                    answer[mh] = getDetector(ass_et)
                elif mh == "type":
                    if ass_et == "site" or ass_et == "sensor":
                        answer[mh] = ass_et
                    pass
        if foal == False:
            print "one of {} must be defined".format(oneAtLeast)
            answer["truth"] =  True
    if answer["truth"]:
        sys.exit()
    return answer

def getSensor(sid):
    if sid.lower() not in lcDict[SENSORS]:
        print sid, "is not an existing sensor. Quiting"
        return None
    else:
        tsid = lcDict[SENSORS][sid.lower()]
        gDict[SENSORS][tsid]["uid"] = tsid
        return gDict[SENSORS][tsid]

def getSite(sid):
    if sid.lower() not in lcDict[SITES]:
        print sid, "is not an existing site. Quiting"
        return None
    else:
        tsid = lcDict[SITES][sid.lower()]
        gDict[SITES][tsid]["uid"] = tsid
        return gDict[SITES][tsid]

def getPair(sid):
    (sensId, sitId) = sid.split(',')
    lePair = "{}.{}".format(sitId, sensId)
    riaPel = "{}.{}".format(sensId, sitId)
    pairs = lcDict[PAIRS]
    print pairs
    if lePair.lower() in pairs.keys():
       rLePair = pairs[lePair.lower()]
       thePair = gDict[PAIRS][rLePair]
       thePair["uid"] = rLePair
    elif riaPel.lower() in pairs.keys():
       rRiaPel = pairs[riaPel.lower()]
       thePair = gDict[PAIRS][rRiaPel]
       thePair["uid"] = rRiaPel
    else:
       print "invalid pair ({} or {}), sorry, can't continue.".format(lePair, riaPel)
       thePair = None
    return thePair

def getDetector(sid):
    (sensId, detId) = sid.split(',')
    sensor = getSensor(sensId)
    if sensor is None:
        return None
    did = "{}.{}".format(sensor["uid"],detId)
    lod = sensor[LISTOFDETECTORS]
    if did.lower() not in lcDict[DETECTORS].keys():
        print "{} is not a detected quantity in {}".format(detId, sensId)
        return None
    (zid, detId) = lcDict[DETECTORS][did.lower()].split(".")
#    print "Located dectector: ", detId
    sensor[DETECTORS][detId]["uid"] = "{}.{}".format(sensor["uid"],detId)
#    print "Detector: ", sensor[DETECTORS][detId]

    return sensor[DETECTORS][detId]

def do_showHelp(gDict, args):
    """
    Function to show help about a given command
    """
    if len(args) == 0:
        h = """uam: The urbanFlows Asset Manager

This is a command line tool which takes several arguments to achieve
different functionality.
You can see all arguments by invoking 'uam' without arguments

Help is provided for each of the possible arguments by typing:

uam showHelp <action>
<action> can be any of:
"""
        print h, theActions
        return
    subject = args[0].lower()
    laKey = None
    for key in helpOrder:
        if subject == key.lower():
            laKey = key
            break
    if laKey is None:
        print "Invalid help action"
        sys.exit()

    aha = actionsHelp[laKey]
    print "Usage:\n    uam", subject, aha["args"]
    print "\n{}".format( aha["long"] )
    sys.exit()

def liveAt(history, limit):
    if limit is None:
        return True
    stt = False
    for h in history:
        if h[TSTAMP] > limit:
            return stt
        if h[HSTATUS] == "on":
            stt = True
        else:
            stt = False
    return stt

def showSite(site, gDict, limitUstamp, hDate, activity):
    if not liveAt(gDict[SITES][site][HISTORY], limitUstamp):
        print site, "not active"
        return

    (dkey, revKey) = revert(["site"])
    if activity:
        print "activity for site: ", site
        k = HISTORY
        print " {}.{}".format(site, k)
        hist = gDict[SITES][site][k]
        showHist(hLabel, None)
        for he in hist:
            showHist(he, limitUstamp)
    else:
        print "Data for site: ", site
        for k in sorted(gDict[SITES][site].keys()):
            if k in dkey:
                dk = dkey[k]
            else:
                dk = k

            if k == HISTORY:
                print " {}.{}".format(site, dk)
                hist = gDict[SITES][site][k]
                showHist(hLabel, None)
                for he in hist:
                    showHist(he, limitUstamp)
            else:
                print " {}.{}= {}".format(site, dk, gDict[SITES][site][k])

def showSensor(sensor, gDict, showH, limitUstamp, hDate, activity):
    leSensor = gDict[SENSORS][sensor]

    if not liveAt(leSensor[HISTORY], limitUstamp):
        print sensor, "not active"
        return

    (dkey, revKey) = revert(["sensor", "detector"])

    # date detection should occur here
    if activity:
        k = HISTORY
        hist = leSensor[k]
        print " {}.{}:".format(sensor, k)
        showHist(hLabel, None)
        for he in hist:
            showHist(he, limitUstamp)
        pass
    else:
        print "Data for sensor: ", sensor 
        for k in sorted(leSensor.keys()): # gDict[SITES][site].keys()):
            if k in dkey:
                dk = dkey[k]
            else:
                dk = k
            if DETECTORS in k:
                continue
            if k == revKey["provider"]:
                p = sorted(leSensor[k].keys())
                for e in p:
                    f = leSensor[k][e]
                    print " {}.{}.{} = {}".format(sensor, dk, e, f)
                pass
            elif k == LISTOFDETECTORS:
                dets = []
                for d in leSensor[k]:
                    dets.append(str(d))
                print " {}.{}= {}".format(sensor, dk, dets)
            elif k == HISTORY and showH == True:
                hist = leSensor[k]
                print " {}.{}:".format(sensor, dk)
                showHist(hLabel, None)
                for he in hist:
                    showHist(he, limitUstamp)
            elif k == HISTORY and showH == False:
                print " {}.{}:".format(sensor, dk)
            else:
                print " {}.{}= {}".format(sensor, dk, leSensor[k])
    
        if showH == False:
            return
        shist = leSensor[HISTORY]
        print sensor,  "detectors:"
        for ms in leSensor[LISTOFDETECTORS]:
            qtty = leSensor[DETECTORS][ms]
            label = "{}.{}".format(sensor, ms)
            print " {:25s}".format(label), ms, qtty['du'], qtty['dz']
    
            if len(qtty[HISTORY]) > 0:
                chist = []
                for h in shist:
                    chist.append(h)
                for h in  qtty[HISTORY]:
                    insert(h, chist)
                print sensor, ms, HISTORY
                showHist(hLabel, None)
                for ch in chist:
                    showHist(ch, limitUstamp)

def showHist(entry, limit):
    """
H_TSTAMP = 0
H_LSTAMP = 1
H_MESSGE = 2
H_STATUS = 3
H_USRNME = 4
    method to show history items
    """
    if entry[H_TSTAMP] is None:
        hrTime = "Date      "
        mrk = " "
        lgt = ""
    else:
        etime = entry[H_TSTAMP] + tOffset
        tag = entry[H_LSTAMP] + tOffset
        lgt = "{:.6f}".format(float( tag ))
        if limit is None:
            mrk = " "
        elif etime < limit:
            mrk = "-"
        else:
            mrk = "+"
        if etime == 32503680000:
            return
        hrTime = datetime.datetime.fromtimestamp( etime).strftime('%Y-%m-%d')

    action = entry[H_MESSGE]
    status = entry[H_STATUS]

    msg = "{}  {:12s} {:25s} {:10s} {}".format(mrk, hrTime, action, status, lgt)
    print msg

def splitArgs(args, nmandatory):
    if len(args) < nmandatory:
        do_showHelp(gDict, [laAction])
    doThis = {}
    todo = []
    for arg in args:
        lcarg = arg.lower()
        if "=" in lcarg:
            lcparts = lcarg.split("=")
            parts = arg.split("=")
            doThis[lcparts[0]] = parts[1]
            todo.append(lcparts[0])
            if lcparts[0] == "src":
                assetsFile = parts[1]
                if not os.path.isfile(assetsFile):
                    print "File {} does not exist.  Quiting".format(assetsFile)
                    sys.exit()
        else:
            doThis[lcarg] = None
            todo.append(lcarg)

    return (doThis, todo)

def do_showThings(gDict, args):
    """
    Function to show any dictionary content
    """

    (doThis, todo) = splitArgs(args, 1)

    showTime = todo[0]
    iDate = None
    hDate = None
    activity = False
    y3k   = stime2utime("10-01-3000")
    if "date" in todo:
        hDate = doThis["date"]
        iDate = stime2utime(doThis["date"])
    if "activity" in todo:
        activity = True

    if showTime == "dictionary":

        if LISTOFSITES in gDict:
            sites = gDict[LISTOFSITES]
            print "\nList of sites: ", sites
            for site in sites:
                showSite(site, gDict, iDate, hDate, activity)
            
        if LISTOFSENSORS in gDict:
            sensors = gDict[LISTOFSENSORS]
            print "\nList of sensors: ", sensors
            for sensor in sensors:
                showSensor(sensor, gDict, False, iDate, hDate, activity)
    
        if PAIRS in gDict:
            pairs = gDict[PAIRS]
            print "\nList of pairs: ", pairs.keys()
            for pair in sorted(pairs.keys()):
                showPair(pair, gDict, iDate, hDate)

    elif showTime == "histories":
        historian(gDict)
        for k in sorted(hStat.keys()):
            print "{} = {}".format(k, hStat[k])

    elif showTime == "asset":
        if doThis[showTime] is None or doThis[showTime] == "":
            print "No asset specified. Use at least asset=*"
            sys.exit()
        dass = lcDict["assets"]
        asset = doThis[showTime].lower()
        found = False
        wc = False
        if "*" in asset:
            wc = True
            asset = doThis[showTime].lower().replace("*","")
        for key in lcDict["assets"].keys():
            if asset  == key or (wc and asset in key):
                found = True
                lcN = lcDict["assets"][key]
                akind = lcDict["loa"][lcN]
                pName = lcDict[akind][key]
                if akind == SENSORS:
                    showSensor(pName, gDict, True, iDate, hDate, activity)
                elif akind == SITES:
                    showSite(pName, gDict, iDate, hDate, activity)
                elif akind == DETECTORS:
                    pName = lcDict[DETECTORS][key]
                    (sid, detectorId) = pName.split(".")
                    showDetector(sid, detectorId, gDict, iDate, hDate, activity)
                elif akind == PAIRS:
                    showPair(pName, gDict, iDate, hDate)
        if not found:
            print "asset {} not found".format(doThis["asset"])
        sys.exit()
        
    elif showTime == "sensor":
        if LISTOFSENSORS in gDict:
            sensors = gDict[LISTOFSENSORS]
            print "sensors list: ", sensors
            mysensor = doThis[showTime].lower()
            if mysensor == "*":
                for sensor in sensors:
                    showSensor(sensor, gDict, False, iDate, hDate, activity)
            else:
                for sensor in sensors:
                    if sensor.lower() == mysensor:
#                    if sensor == mysensor:
                        showSensor(sensor, gDict, True, iDate, hDate, activity)
                        break
            
    elif showTime == "site":
        if LISTOFSITES in gDict:
            sites = gDict[LISTOFSITES]
            print "sites list: ", sites
            mysite = doThis[showTime].lower()
            if mysite == "*":
                for site in sites:
                    showSite(site, gDict, iDate, hDate, activity)
            else:
                for site in sites:
                    if site.lower() == mysite:
                        showSite(site, gDict, iDate, hDate, activity)
            
        pass

    elif showTime == LOGGER:
        if LOGGER in gDict:
            logs = gDict[LOGGER]
            for log in logs:
                hrTime = datetime.datetime.fromtimestamp( float(log[L_LTIME] + tOffset)).strftime('%a %d-%m-%Y %H:%M:%SZ')
#                if TSTAMP in log:
                if True:
                    ts = int(log[L_TSTAMP] + tOffset)
                    rem = ts%86400
                    if rem == 0:
                        hrXtime = datetime.datetime.fromtimestamp( float(ts )).strftime('%a %d-%m-%Y')
                    else:
                        hrXtime = datetime.datetime.fromtimestamp( float(ts)).strftime('%a %d-%m-%YT%H:%M:%S')
                else:
                    hrXtime = None
                    ts = None
                    rem = None
#                print hrTime, log[HACTION], "on", log[XDATE]
                print hrTime, log[L_ACTION], "@", hrXtime
        pass

    elif showTime == "chronology":
        if LOGGER in gDict:
            logs = gDict[LOGGER]
            tdic = {}
            nl = 0
            for log in logs:
                key = "{}_{}".format(log[L_TSTAMP], nl)
                tdic[key ]  = log
                nl += 1

            for logk in sorted(tdic.keys()):
                log = tdic[logk]
                hrTime = datetime.datetime.fromtimestamp( float(log[L_LTIME] + tOffset)).strftime('%a %d-%m-%Y %H:%M:%S.%fZ')
#                if TSTAMP in log:
                if True:
                    ts = int(log[L_TSTAMP] + tOffset)
                    rem = ts%86400
                    if rem == 0:
                        hrXtime = datetime.datetime.fromtimestamp( float(ts )).strftime('%a %d-%m-%Y')
                    else:
                        hrXtime = datetime.datetime.fromtimestamp( float(ts)).strftime('%a %d-%m-%YT%H:%M:%S')
                else:
                    hrXtime = None
                    ts = None
                    rem = None

#                print hrTime, log[HACTION], "on", log[XDATE], ts, rem, hrXtime
                print hrTime, log[L_ACTION], "@", hrXtime
        pass

    elif showTime == "detector":
        # we show information for a single detector in the form MOT720,TEMP
        # ie, 
        # for sensorID,detectorID or
        # for sensorID,*  or
        # for *,detectorID or 
        # for *,*
        mydet = doThis[showTime]
#        import re
#        parts = re.findall(r"[\w']+", mydet)
#        print parts
        if mydet == "*":
            losDetectors = []
            for d in  sorted(lcDict[DETECTORS].keys()):
                if "." in d:
                    losDetectors.append( lcDict[DETECTORS][d] )
            print "Detectors: ", losDetectors
            sys.exit()

        cs = decodeAsset(mydet)
        (sensorId, detectorId) = (cs[0].lower(), cs[1].lower())
        if iDate is None:
            print "Info for {} ".format( mydet)
        else:
            print "Status for {} on {}".format( mydet, hDate)
        sensors = gDict[SENSORS]
        if sensorId == "*":
            if detectorId == "*":
                for sid in sensors.keys():
                    dets = sensors[sid][DETECTORS]
                    for det in dets.keys():
                        showDetector(sid,det, gDict, iDate, hDate, activity)
            else:
                detectorId = lcDict[DETECTORS][detectorId]
                for sid in sensors.keys():
                    dets = sensors[sid][DETECTORS]
                    if detectorId not in dets:
                        print "Beep... {} not a valid detector".format(detectorId)
                    showDetector(sid,detectorId, gDict, iDate, hDate, activity)
                pass
        else:
            sensorId = lcDict[SENSORS][sensorId]
            if sensorId not in sensors:
                print "Beep... {} not a valid sensor".format(sensorId)
                sys.exit()
            if detectorId == "*":
                sid = sensors[sensorId]
                dets = sid[DETECTORS]
                for det in dets.keys():
                    showDetector(sensorId,det, gDict, iDate, hDate, activity)
            else:
                detectorId = lcDict[DETECTORS][detectorId]
                dets = sensors[sensorId][DETECTORS]
                if detectorId not in dets:
                    print "Beep... {} not a valid detector".format(detectorId)
                showDetector(sensorId,detectorId, gDict, iDate, hDate, activity)
                pass
        pass
    elif showTime == "pair":
        if PAIRS in gDict:
            pairs = lcDict[PAIRS]
            mypair = doThis[showTime].replace(",",".").replace(":",".")
            if mypair == "*":
                for pair in sorted(pairs.keys()):
                    showPair(pairs[pair], gDict, iDate, hDate)
                pass
            else:
                if mypair in pairs:
                    for pair in sorted(pairs.keys()):
                        if mypair.lower() == pair.lower():
                            showPair(lcDict[PAIRS][pair], gDict, iDate, hDate)
                else:
                    # here, we need to see if the second component is '*'
                    found = False
                    for pair in sorted(pairs.keys()):
                        q = mypair.lower().replace("*","").replace(".","")
                        if q in pair.lower():
                            showPair(lcDict[PAIRS][pair], gDict, iDate, hDate)
                            found = True
                    if not found:
                        print mypair, "not in", pairs.keys()
                pass
        else:
            print "No pairs defined yet"

    elif showTime == "activity":
        # show the active period for an asset or all assets if no argument
        # is given
        pass
    elif showTime == "operational":
        # show those assets which are operational either "today" or at the
        # specified date
        (dkey, revKey) = revert(["detector"])
        if iDate is None:
            hDate = heute
            iDate = stime2utime(hDate)
        if PAIRS not in gDict:
            print "#Nothing to do. Sorry"
            sys.exit()

        pairs = gDict[PAIRS]
        mypair = doThis[showTime]
        pcount = 1
        for pair in sorted(pairs.keys()):
            tev = histoire(hDate,"test", "undef");
            status = getStatus(tev, pairs[pair][HISTORY])
            (siteId, sensorId) = pair.split(".")
            leSite = gDict[SITES][siteId]
            leSensor = gDict[SENSORS][sensorId]
            siteStatus = getStatus(tev, leSite[HISTORY])
            shist = leSensor[HISTORY]
            sensorStatus = getStatus(tev, shist)
            if (status != "on") or (siteStatus != "on") or (sensorStatus != "on"):
                continue
            longi = gDict[SITES][siteId][SITELON]
            lati  = gDict[SITES][siteId][SITELAT]
            dets = leSensor[DETECTORS]
            d3 = []
            for detname in dets:
                det = dets[detname]
                chist = []
                for sh in shist:
                    chist.append(sh)
                deth = det[HISTORY]
                for dh in deth:
                    insert(dh, chist)
                detStatus = getStatus(tev, chist)
                print det[revKey["name"]], detStatus
                if detStatus != "on":
                    continue
                d3.append("{}:{}:{}".format(det[revKey["name"]],
                        det[revKey["unit"]], det[revKey["ucd"]]) )
            print "{}:{},{},{},{},{},{},{}".format(siteId,sensorId,
            lati,longi, pcount, "Time", sensorStatus, "|".join(d3))
            pcount += 1
        pass
    else:
        print "unrecognised operation: ", showTime

    sys.exit()

def decodeAsset(asset):
    ac = []
    if "." in asset:
        ac = asset.split('.')
    elif "," in asset:
        ac = asset.split(',')
    elif ":" in asset:
        ac = asset.split(':')
    return ac

def identifyStatus(asset, history, stvalue, fDate, tDate, verbus):
    """
    Rescue periods in which the status component equals stvalue
    """
    first = False
    intervals = []
    pair = []
    for h in history:
        th = h[H_TSTAMP] #+ tOffset

        sth = h[H_STATUS]
        if verbus:
            print asset, fDate + tOffset, h[H_TSTAMP] + tOffset, tDate + tOffset, sth
        if sth == stvalue:
            pair = []
            pair.append(th)
            first = True
        else:
            if first:
                pair.append(th)
                intervals.append(pair)
                first = False
    for i in intervals:
        if i[0] < fDate:
            if i[1] < fDate:
                continue
            else:
                i[0] = fDate
        if i[0] > tDate:
            if i[1] > tDate:
                continue
            else:
                i[1] = tDate
        elif i[1] > tDate:
            i[1] = tDate
        t0 = datetime.datetime.fromtimestamp( int(i[0]+tOffset)).strftime('%d-%m-%Y')
        t1 = datetime.datetime.fromtimestamp( int(i[1]+tOffset)).strftime('%d-%m-%Y')
        print asset, t0, t1, stvalue


def do_identifyStatus(gDict, args):
    """
    Function to show periods in which an asset has a given status
    """

    (doThis, todo) = splitArgs(args, 2)
    fail = checkPresence(doThis, [CLSTATUS], ["sensor","site","pair", "detector"])
    if fail["truth"]:
        sys.exit()

    
    asset = todo[0]
    if CLSTATUS in doThis:
        status = doThis[CLSTATUS]
    else:
        print "No status has been specified"
        sys.exit()
    iDate = None
    hDate = None
    activity = False
    y3k   = stime2utime("10-01-3000")
    if "from" in todo:
        fDateH = doThis["from"]
    else:
        fDateH = "01-01-2000"
    fDate = stime2utime(fDateH)
    if "to" in todo:
        tDateH = doThis["to"]
    else:
        tDateH = heute
    if "verbose" in todo:
        verbose = True
    else:
        verbose = False
    tDate = stime2utime(tDateH)

    if "activity" in todo:
        activity = True


    if asset == "sensor":
        if LISTOFSENSORS in gDict:
            sensors = lcDict[LISTOFSENSORS]
            mysensor = doThis[asset]
            if mysensor == "*":
                theSensors = sensors
            else:
                if mysensor.lower() in sensors:
                    theSensors = [ sensors[mysensor.lower() ]  ]
                else:
                    print mysensor, "is not recognised as a sensor"
                    sys.exit()
            for sensor in theSensors:
                identifyStatus(sensor, gDict[SENSORS][sensor][HISTORY],
                            status, fDate, tDate, verbose)
            
    elif asset == "site":
        if LISTOFSITES in gDict:
            sites = lcDict[LISTOFSITES]
            mysite = doThis[asset].lower()
            theSites = []
            if mysite == "*":
                theSites = sites
            else:
                if mysite in sites:
                    theSites = [ sites[mysite] ]
                else:
                    print mysite, "is not recognised as a site"
                    sys.exit()
            for site in theSites:
                identifyStatus(site, gDict[SITES][site][HISTORY],
                            status, fDate, tDate, verbose)
            
        pass

    elif asset == "detector":
        # we show information for a single detector in the form MOT720,TEMP
        # ie, 
        # for sensorID.detectorID or
        # for sensorID.*  or
        # for *.detectorID or 
        # for *.*
        mydet = doThis[asset].lower()
        if "*" in mydet:
            wcDet = mydet.replace("*","")
            dets = lcDict[DETECTORS]
            for d in dets.keys():
                if wcDet in d:
                    if "." not in d:
                        continue
                    gDet = dets[d]
                    (tSens, tDet) = gDet.split(".")
                    shist = gDict[SENSORS][tSens][HISTORY]
                    dHist = []
                    for h in shist:
                        dHist.append(h)
                    for h in gDict[SENSORS][tSens][DETECTORS][tDet][HISTORY]:
                            insert(h, dHist)
                    identifyStatus(gDet,
                                dHist, status, fDate, tDate, verbose)
            sys.exit()

        (sensorId, detectorId) = mydet.split(".")
        if iDate is None:
            print "Info for {} ".format( mydet)
        else:
            print "Status for {} on {}".format( mydet, hDate)
        sensors = lcDict[SENSORS]
        gSensors = gDict[SENSORS]
        if sensorId == "*":
            if detectorId == "*":
                for sid in sensors.keys():
                    tSens = sensors[sid]
                    shist = gDict[SENSORS][tSens][HISTORY]
                    dets = gSensors[tSens][DETECTORS]
                    for det in dets.keys():
                        dHist = []
                        for h in shist:
                            dHist.append(h)
                        for h in gDict[SENSORS][tSens][DETECTORS][det][HISTORY]:
                            insert(h, dHist)
                        identifyStatus("{}.{}".format(sid,det),
                                dHist, status, fDate, tDate, verbose)
            else:
                for sid in sensors.keys():
                    tSens = sensors[sid]
                    gSensor = gDict[SENSORS][ tSens ]
                    shist = gSensor[HISTORY]
                    dets = lcDict[DETECTORS]
                    leDet = "{}.{}".format(sid,detectorId)
                    if leDet not in dets:
                        print "Beep... {} not a valid detector".format(detectorId)
                        sys.exit()
                    detc = dets[detectorId]
                    dHist = []
                    for h in shist:
                        dHist.append(h)
                    for h in gDict[SENSORS][tSens][DETECTORS][detc][HISTORY]:
                        insert(h, dHist)
                    identifyStatus("{}.{}".format(sid,detectorId),
                            dHist, status, fDate, tDate, verbose)
                pass
        else:
            if sensorId not in sensors:
                print "Beep... {} not a valid sensor".format(sensorId)
                sys.exit()
            leSensor = sensors[sensorId]
            gSensor = gDict[SENSORS][leSensor]
            shist = gSensor[HISTORY]
            if detectorId == "*":
                dets = gSensor[DETECTORS]
                for det in dets.keys():
                    dHist = []
                    for h in shist:
                        dHist.append(h)
                    for h in gDict[SENSORS][leSensor][DETECTORS][det][HISTORY]:
                        insert(h, dHist)
                    identifyStatus("{}.{}".format(leSensor,det),
                             dHist, status, fDate, tDate, verbose)
            else:
                dets = lcDict[DETECTORS]
                if detectorId not in dets:
                    print "Beep... {} not a valid detector".format(detectorId)
                dHist = []
                for h in shist:
                    dHist.append(h)
                for h in gDict[SENSORS][leSensor][DETECTORS][dets[detectorId]][HISTORY]:
                    insert(h, dHist)
                identifyStatus("{}.{}".format(leSensor,dets[detectorId]),
                    dHist, status, fDate, tDate, verbose)
                pass
        pass
    elif asset == "pair":
        if PAIRS in gDict:
            pairs = gDict[PAIRS]
            mypair = doThis[asset]
            if mypair == "*":
                for pair in sorted(pairs.keys()):
                    identifyStatus(pair,
                        gDict[PAIRS][pair][HISTORY],
                        status, fDate, tDate, verbose)
                pass
            else:
                if "*" in mypair:
                    lePair = mypair.lower().replace("*","")
                    for pair in sorted(pairs.keys()):
                        if lePair in pair.lower():
    #                        showPair(pair, gDict, iDate, hDate)
                            identifyStatus(pair,
                                gDict[PAIRS][pair][HISTORY],
                                status, fDate, tDate, verbose)
                else:
                    for pair in sorted(pairs.keys()):
                        if mypair.lower() == pair.lower():
    #                        showPair(pair, gDict, iDate, hDate)
                            identifyStatus(pair,
                                gDict[PAIRS][pair][HISTORY],
                                status, fDate, tDate, verbose)
                pass

    else:
        print "unrecognised operation: ", asset

    sys.exit()

def revert(objectList):
    if len(objectList) > 1:
        name = "-".join(objectList)
        if name not in revTemplate:
            ognil = {}
            dcle = {}
            for ol in objectList:
                lingo = templateObjs[ol]
                for l in lingo:
                    for k in l.keys():
                        ognil[ l[k] ] = k
                        dcle[k] = l[k]
            revTemplate[name] = ognil
            dirTemplate[name] = dcle
            pass
        
    else:      #   for objectd in objectList:
        name = objectList[0]
        if name not in revTemplate:
            lingo = templateObjs[name]
            ognil = {}
            dcle = {}
            for l in lingo:
                for k in l.keys():
                    ognil[ l[k] ] = k
                    dcle[k] = l[k]
            revTemplate[name] = ognil
            dirTemplate[name] = dcle
    return dirTemplate[name], revTemplate[name]

def showDetector(sensorId,detectorId, gDict, limitUstamp, hDate, activity):
    det = gDict[SENSORS][sensorId][DETECTORS][detectorId]
    status = ""

    dkey, vale = revert(["detector"])
    unit = "[{}]".format(det[vale["unit"]])
    error = det[vale["epsilon"]]
    dpair = "{}.{}".format(sensorId, detectorId)
    shist = gDict[SENSORS][sensorId][HISTORY]
    chist = []
    for h in shist:
        chist.append(h)
    for h in  det[HISTORY]:
        insert(h, chist)
    if limitUstamp is None:
        print "{:15s} {:8s} +/- {:8s} {:8s} {:8s}".format(dpair, unit,
                error, det[vale["ucd"]], status)
        print "{}'s history:".format(dpair)
        showHist(hLabel, None)
        for ch in chist:
            showHist(ch, limitUstamp)
        pass
    else:
        tev = histoire(hDate,"test", "undef");
        status = getStatus(tev, chist)
        print "{:15s} {:8s} +/- {:8s} {:8s} {:8s}".format(dpair, unit,
                error, det[vale["ucd"]], status)

def showPair(pair, gDict, limitUstamp, hDate):
    lePair = gDict[PAIRS][pair][HISTORY]
    if not liveAt(lePair, limitUstamp):
        print pair, "not active"
        return
    print "Pair ", pair #, lePair, limitUstamp
    showHist(hLabel, None)
    pairs = gDict[PAIRS]
    for hist in lePair:
        showHist(hist, limitUstamp)


def cleanDict(obj):
    if type(obj) == dict:
        for k, v in obj.items():
            if hasattr(v, '__iter__'):
                cleanDict(v)
            else:
                if k == "uid":
                    print 'ack!! %s : %s' % (k, v)
                    del obj[k]
                else: 
                    pass
    elif type(obj) == list:
        for v in obj:
            if hasattr(v, '__iter__'):
                cleanDict(v)
            else:
                pass
    else:
        pass



#def do_addSite(fields, gDict, args):
#    """
#    Function to collect data about a site from stdin
#    """
#    site = {}
##    print "addSite - Things to extract ", fields
#    for f in fields:
#        while  True:
#            fname = raw_input("\t" + handles[f] + ": ")
#            if len(fname) > 0:
#                site[f] = fname
#                break
#    appendSite(site)


def appendSite(site, kv):
    firstDate = kv["firstdate"]
    if site[firstDate] == "today":
        site[firstDate] =  time.strftime(idf)

    sdft =  site[firstDate]
    sdu = stime2utime(sdft)
    site[kv["epoch.f"]] = sdu
    site[kv["date.l"]] = "01-01-3000"
    fdu = stime2utime(site[kv["date.l"]])
    site[kv["epoch.l"]] = fdu
    site[HISTORY] = []
    opera = kv["operator"]
    if opera in site:
        operator = site[opera]
        if "|" in operator:
            parts = operator.split("|")
            obi = {}
            for p in parts:
                k_v = p.split(":")
                obi[k_v[0]] = k_v[1]
            site[opera] = obi
        else:
            site[opera] = { "id" : operator}
        
    seatid = kv["siteid"]
    sid = site[seatid]
    if SITES not in gDict:
        gDict[SITES] = {}
    if LISTOFSITES not in gDict:
        gDict[LISTOFSITES] = []
    if sid in gDict[SITES]:
        msg = "overwriteSite"
    else:
        gDict[LISTOFSITES].append(sid)
        msg = "addSite"

    gDict[SITES][sid] = site
    event = ulogger(sdft, "{} {}".format(msg,sid) )
    gDict[LOGGER].append(event)
    print "{} site {} on {}".format(msg,sid, sdft)
    stamp = histoire(sdft, "operational", "deployed")
    site[HISTORY].append(stamp)
    if msg == "addSite":
        stamp = histoire("01-01-3000","decommissioned", "dead");
        site[HISTORY].append(stamp)


def checkArgs(args, nmandatory):
    if len(args) < nmandatory:
        do_showHelp(gDict, [laAction])


def do_addSitesFromFile(gDict, args):
    """
    Function to collect data about a site from stdin
    """
    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["file"], [])
    if fail["truth"]:
        sys.exit()

        
    fileName = fail["file"] # todo[0]
    if not os.path.isfile(fileName):
        print fileName, " does not exist. Quiting"
        sys.exit()


    dfile = open(fileName,"r")
    lines = dfile.read().splitlines()
    dfile.close()
    dkey, walkeyrie = revert(["site"])

    site = {}
    for line in lines:
        if len(line) < 2:
            continue
        if line == "begin.asset":
            pass
        elif line != "end.asset":
            kv = line.split("=")
            k0 = kv[0]
            if k0 in walkeyrie:
                site[ walkeyrie[k0] ] = kv[1]
            else:
                site[ k0 ] = kv[1]
        else:
            appendSite(site, walkeyrie)
            site = {}


def do_createTemplate(gDict, args):
    """
    Function to create input templates for sensors and sites
    """

    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["type"], [])
    kind = fail["type"] # todo[0]
    if fail["truth"]:
        print kind, " makes no sense"
        sys.exit()
    n = 1
    if "n" in doThis:
        n = int(doThis["n"])
    if kind != "sensor" and kind != "site":
        print kind, " must be either sensor or site"
        sys.exit()

    fields = templateObjs[kind]
    examples = {
        "operator" : "id:xx|contact:xx|tel:xxxyyyyzzz|email:xxx@yyy",
        "provider" : "id:xx|contact:xx|tel:xxxyyyyzzz|email:xxx@yyy",
        "firstdate": "DD-MM-YYYY",
        "energysupply": "solar|mains",
    }
    hide = ["listOfDetectors", "detector", "epoch.f", "date.l", "epoch.l", "history", "username"]
    for i in range(0,n):
        print "begin.asset"
        for uf in fields:
            uk = uf.keys()
            for f in uk:
                uff = uf[f]
                if uff in hide:
                    continue
                if uff == "n-detectors":
                    print "# add more detectors if necessary"
                    for i in range(0,5):
                        print "detector=name:xxx|unit:xx|epsilon:xx"
                    break
                if uff in examples:
                    print "{}={}".format(uff, examples[uff])
                else:
                    print "{}=".format(uff)
        print "end.asset\n"
    sys.exit()


def appendSensor(sensor, kv):
    firstdate = kv["firstdate"]
    if sensor[firstdate] == "today":
        sensor[firstdate] =  time.strftime(idf)

    sdft =  sensor[firstdate]
    sdu = stime2utime(sdft)
    sensor[kv["epoch.f"]] = sdu
    sensor[kv["date.l"]] = "01-01-3000"
    fdu = stime2utime(sensor[kv["date.l"]])
    sensor[kv["epoch.l"]] = fdu
    sensor[HISTORY] = []
    stamp = histoire(sdft,"commisioned", "hold");
    sensor[HISTORY].append(stamp)
    stamp = histoire("01-01-3000","decommisioned", "off");
    sensor[HISTORY].append(stamp)

    lesDetectors = sensor[DETECTORS]
    for det in sorted(sensor[DETECTORS].keys()):
        lesDetectors[det][HISTORY] = []

    prova = kv["provider"]
    if prova in sensor:
        provider = sensor[prova]
        if "|" in provider:
            parts = provider.split("|")
            obi = {}
            for p in parts:
                k_v = p.split(":")
                obi[k_v[0]] = k_v[1]
            sensor[prova] = obi
        else:
            sensor[prova] = { "id" : provider}

    sid = sensor[kv["sensorid"]]
    if SENSORS not in gDict:
        gDict[SENSORS] = {}
    if LISTOFSENSORS not in gDict:
        gDict[LISTOFSENSORS] = []
    if sid in gDict[SENSORS]:
        msg = "overwriteSensor"
    else:
        gDict[LISTOFSENSORS].append(sid)
        msg = "addSensor"
    gDict[SENSORS][sid] = sensor
    event = ulogger(sdft, "{} {}".format(msg,sid))
    gDict[LOGGER].append(event)


def do_addSensorsFromFile(gDict, args):
    """
    Function to collect data about sensors from a file
    """

    (doThis, todo) = splitArgs(args, 1)
    fail = checkPresence(doThis, ["file"], [])
    if fail["truth"]:
        sys.exit()

    fileName = doThis["file"]
    if not os.path.isfile(fileName):
        print fileName, " does not exist. Quiting"
        sys.exit()

    dkey, walkeyrie = revert(["sensor","detector"])

    dfile = open(fileName,"r")
    lines = dfile.read().splitlines()
    dfile.close()
    sensor = {}
    lquant  = []
    quant = {}
    sensorid = "undef"
    for line in lines:
        if len(line) < 2:
            continue
        if "#" in line:
            continue
        if line == "end.asset":
            if "detector" in sensor:
                del sensor["detector"]
            sensor[DETECTORS] = quant
            sensor[LISTOFDETECTORS] = lquant
            appendSensor(sensor, walkeyrie)

            sensor = {}
            lquant  = []
            quant = {}
        elif line == "begin.asset":
            pass
        else:
            k_v = line.split("=")
            k0 = k_v[0]
            k1 = k_v[1]
            if k0 == "sensorid":
                sensorid = k1
            if k0 == "detector":
                qs = k1.split("|")
                obi = {}
                for qq in qs:
                    qt = qq.split(":")
                    obi[walkeyrie[ qt[0] ] ] = qt[1]
                qN = obi[walkeyrie["name"]]
                obi[ walkeyrie["ucd"] ] = getUCD(qN, sensorid)
                lquant.append(qN)
                quant[qN] = obi
            else:
                sensor[walkeyrie[k0]] = k1

def getUCD(name, sensor):
    ucd = None
    for k in ucds.keys():
        if name in ucds[k]:
            ucd = k
            break
    if ucd is None:
        print "Warning, *{}.{}* could not be assigned a known UCD".format(sensor, name)
    return ucd


def do_activateSensorInSite(gDict, args):
    """
    Function to attach a sensor to a site
    """

    (doThis, todo) = splitArgs(args, 3)
    fail = checkPresence(doThis, ["sensor", "site", "date"], [])
    if fail["truth"]:
        sys.exit()


    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    date = doThis["date"]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
                            "activating")

    fdu = stime2utime(date)
    if PAIRS not in gDict:
        print "Pair sensor/site is not present. Doing nothing"
        sys.exit()
    pairs = gDict[PAIRS]
    tag = "{}.{}".format(siteKey, sensorKey)
    print "Taking: {} at {} ({}) live on: {} ".format(sensorid,siteid,tag,date)
    if tag not in pairs:
        pairs[tag] = []
    tev = histoire(date,"running", "on");

    insert(tev, pairs[tag][HISTORY])

    insert(tev, gDict[SENSORS][sensorKey][HISTORY])
    msg = "{} activated at {}".format(sensorKey, siteKey)
    event = ulogger(date, msg)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} activated".format(sensorKey), "on");
    insert(tev, shist)


def getSenSite(gDict, sensorid, siteid, date, what):
    sites = gDict[SITES]
    sensors = gDict[SENSORS]
    siteKey = None
    sensorKey = None
    leSite = None
    leSensor = None
    for site in sites.keys():
        if site.lower() == siteid:
            siteKey = site
            leSite = sites[site]
            break
            
    for sensor in sensors.keys():
        if sensor.lower() == sensorid:
            sensorKey = sensor
            leSensor = sensors[sensor]
            break
            
    if sensorKey is None:
        print "Invalid sensor: ", sensorid
    if siteKey is None:
        print "Invalid site: ", siteid

    # We need to require that both site and sensor are active at the time
    # point of attachement
    siteDate = leSite[HISTORY][0][H_TSTAMP]
    sensorDate = leSensor[HISTORY][0][H_TSTAMP]

    if sensorDate < siteDate:
        print "Causality violation while {}. Quiting. {} newer than {}".format(what, siteid, sensorid)
        sys.exit()

    return (siteKey, sensorKey)

def do_attachSensorToSite(gDict, args):
    """
    Function to attach a sensor to a site
    """

    (doThis, todo) = splitArgs(args, 4)
    fail = checkPresence(doThis, ["sensor","site", "hag", "date"], [])
    if fail["truth"]:
        sys.exit()
    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    hag = doThis["hag"]
    date = doThis["date"]
    ucSiteId = lcDict["sites"][siteid]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
    "attaching")

    fdu = stime2utime(date)
    if PAIRS not in gDict:
        gDict[PAIRS] = {}
    pairs = gDict[PAIRS]
    tag = "{}.{}".format(siteKey, sensorKey)
    print "pairing: ", sensorid, siteid, date, fdu, "as", tag
    if tag not in pairs:
        pairs[tag] = {"ph":hag, HISTORY:[]}
    tev = histoire(date,"attach", "active");
    insert(tev, pairs[tag][HISTORY])

    tev = histoire(date,"attached to {}".format(ucSiteId), "active");
    insert(tev, gDict[SENSORS][sensorKey][HISTORY])
    msg = "{} installed at {}".format(sensorKey, siteKey)
    event = ulogger(date, msg)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} attached".format(sensorKey), "att");
    insert(tev, shist)


def insert(stamp, aList):
    """
    Function to insert a time stamp defined by "histoire()" into a list of
    these elements so that the list is always time sorted
    """
    nTime = stamp[H_TSTAMP]
    lSize = len(aList)
    if lSize == 0:
        aList.append(stamp)
        end = histoire("01-01-3000","theEnd", "dead")
        aList.append(end)
    else:
        top = lSize - 1
        for i in range(0,top):
            if nTime >= aList[i][H_TSTAMP] and nTime < aList[i+1][H_TSTAMP]:
                aList.insert(i+1,stamp)
                break

def getStatus(eve, things):

    nThings = len(things)
    if nThings == 0:
        return "undef"
    else:
        top = nThings - 1
        nTime = eve[H_TSTAMP]
        for i in range(0,top):
            thing = things[i]
            hrTime = datetime.datetime.fromtimestamp( int(thing[H_TSTAMP])).strftime('%Y-%m-%d')
            if nTime >= things[i][H_TSTAMP] and nTime < things[i+1][H_TSTAMP]:
                return things[i][H_STATUS]

def do_detachSensorFromSite(gDict, args):
    """
    Function to detach a sensor from a site
    """

    (doThis, todo) = splitArgs(args, 3)
    fail = checkPresence(doThis, ["sensor","site", "date"], [])
    if fail["truth"]:
        sys.exit()
    sensorid = doThis["sensor"].lower()
    siteid = doThis["site"].lower()
    date = doThis["date"]

    (siteKey, sensorKey) = getSenSite(gDict, sensorid, siteid, date,
                "detacching")


    fdu = stime2utime(date)
    if PAIRS not in gDict:
        print "No pairs have been defined yet. Doing nothing"
        sys.exit()
    pairs = gDict[PAIRS]
    tag = "{}.{}".format(siteKey, sensorKey)
    print "Detaching: ", sensorid, siteid, date, fdu, tag
    if tag not in pairs:
        # this should be an error, it should not be possible to detach a
        # sensor from a non-existent pair
        print "{} is not a valid pair. Doing nothing".format(tag)
        sys.exit()
    tev = histoire(date,"detach", "off");
    insert(tev, pairs[tag][HISTORY])
    # modify the sensor's general history
    insert(tev, gDict[SENSORS][sensorKey][HISTORY])

    msg = "{} detached from {}".format(sensorKey, siteKey)
    event = ulogger(date, msg)
    gDict[LOGGER].append(event)
    shist = gDict[SITES][siteKey][HISTORY]
    tev = histoire(date,"{} detached".format(sensorKey), "kaput");
    insert(tev, shist)

def lcClone(gDict):
    lcd = {}
    lcd["assets"] = {}
    ass_et = lcd["assets"]
    lcd["loa"] = [SITES, SENSORS, PAIRS, DETECTORS, "oq"]
    lcd["masks"] = [1, 2, 4, 8, 16, 32]
    if SITES in gDict:
        lcd[SITES] = {}
        lcd[LISTOFSITES] = {}
        lcds = lcd[SITES]
        for sk in gDict[SITES].keys():
            lsk = sk.lower()
            lcd[LISTOFSITES][lsk] = sk
            lcds[lsk] = sk
            ass_et[lsk] = 0


    if PAIRS in gDict:
        lcd[PAIRS] = {}
        lcdp = lcd[PAIRS]
        for sk in gDict[PAIRS].keys():
            lsk = sk.lower()
            lskDot = lsk.replace("|", ".")
            lcdp[lskDot] = sk
            ass_et[lskDot] = 2
        pass
    if SENSORS in gDict:
        lcd[SENSORS] = {}
        lcd[LISTOFSENSORS] = {}
        lcd[DETECTORS] = {}
        lcd["oq"] = {}
        lcdz = lcd[SENSORS]
        lcdd = lcd[DETECTORS]
        los = lcd[LISTOFSENSORS]
        lcq = lcd["oq"]
        for sk in gDict[SENSORS].keys():
            ld = gDict[SENSORS][sk]["ld"]
            lcz = sk.lower()
            los[sk.lower()] = sk
            lcdz[lcz] = sk
            ass_et[lcz] = 1
            for d in ld:
                dk = "{}.{}".format(lcz, d.lower())
                lcdd[dk] = "{}.{}".format(sk,d)
                lcdd[d.lower()] = d
                ass_et[dk] = 3
                lcq[d.lower()] = d
                ass_et[d.lower()] = 4
    return lcd

#  End of the function definitions
#  main code starts here

if os.path.isfile(assetsFile):
    dfile = open(assetsFile,"r")
    jsonString = dfile.readline().rstrip('\n')
    gDict = json.loads(jsonString)
    lcDict = lcClone(gDict)
    dfile.close()
else:
    gDict = {}
    gDict["time-offset"] = tOffsetDef
    gDict[LOGGER] = []

tOffset = gDict["time-offset"] 

functions = {}
# the next two functions are being deprecated as of Dec 7, 2017  PH+76
# functions["addsite"] = do_addSite;
# functions["addsensor"] = do_addSensor;

# allows to add data for a list of sites stored on a file in the form of
# key-value pairs (one per line). There is no restriction as to the
# elements to go into the dictionary, but a few are mandatory
functions["addsitesfromfile"] = do_addSitesFromFile;

# ditto for sensor boxes
functions["addsensorsfromfile"] = do_addSensorsFromFile;

# Records in the PAIRS and in the "site" history the installation of a sensor
# box in a given site. Note that this action does not mean that the detectors
# or the sensor as a whole are marked as producing reliable data.
# In fact, there can be a gap of several days between the date of the
# installation and the time in which reliable data starts being gathered.
# The sensor/site entry is marked with  "status=active"
functions["attachsensortosite"] = do_attachSensorToSite;

# Records in the PAIRS and "site" history that a sensor has started
# gathering reliable data at a given date.
# The sensor/site entry is marked with  "status=on"
functions["activatesensorinsite"] = do_activateSensorInSite;

# Records in the PAIRS and "site" history that a sensor has been removed
# from a "site" at a certain date.
# The sensor/site entry is marked with  "status=off"
functions["detachsensorfromsite"] = do_detachSensorFromSite;

# Add information to several assets
functions["addinfo"] = do_addInfo;
# Remove information from several assets: history entries and fields.
functions["rminfo"] = do_rmInfo;

# All previous functions alter the dictionary and rewrite a new version.

# The functions below do not alter the dictionary, they only examine its
# current content
#functions["showdictionary"] = do_showDictionary;
functions["show"] = do_showThings;
functions["help"] = do_showHelp;
functions["getinputtemplate"] = do_createTemplate;
functions["identify"] = do_identifyStatus;
#functions["showsensorsite"] = do_showSensorSite;


theActions = sorted(functions.keys())
args = sys.argv
executable = args.pop(0)
ex = executable.split("/")
execute = ex.pop()
nargs = len(args)

if nargs == 0:
    print "Usage: uam <action> <args>"
    print "  where action can be any of:"
#    for a in sorted(actionsHelp):
    for a in helpOrder:
        b = a.lower()
        if b in functions:
            mark = ""
        else:
            mark = "[TODO]"
        aha = actionsHelp[a]
        print "   ", mark, a, aha["args"], "\n\t", aha["short"]
    sys.exit()

uname = getpass.getuser()
laAction = args[0]
args.pop(0)
#print "dealing with action", laAction
lcname = laAction.lower()
#print "the action is: ", laAction , " --> ", lcname

laKey = None
for key in actionsHelp.keys():
   if lcname == key.lower():
       laKey = key
       break
if laKey is None:
    print lcname, "is not a valid action. Please fix"
    print lcname, "NSA: No Such Action"
    sys.exit()
#functions[lcname](arguments[lcname], gDict, args)
if lcname not in functions:
    print lcname, "NSA: No Such Action"
    sys.exit()
functions[lcname](gDict, args)

cleanDict(gDict)
assetsLog = open(assetsFile,'w')
assetsLog.write(json.dumps(gDict))
assetsLog.close()

backup = "{}_{}".format(assetsFile, stamp)
assetsBU = open(backup,'w')
assetsBU.write(json.dumps(gDict))
assetsBU.close()


sys.exit()

